{
version: 3,
sources: [
"webpack:///webpack/universalModuleDefinition",
"webpack:///axios.min.js",
"webpack:///webpack/bootstrap 6f5fdb0af744004f46bc",
"webpack:///./index.js",
"webpack:///./lib/axios.js",
"webpack:///./lib/utils.js",
"webpack:///./~/buffer/index.js",
"webpack:///./~/base64-js/index.js",
"webpack:///./~/ieee754/index.js",
"webpack:///./~/isarray/index.js",
"webpack:///./lib/helpers/bind.js",
"webpack:///./lib/core/Axios.js",
"webpack:///./lib/defaults.js",
"webpack:///./lib/helpers/normalizeHeaderName.js",
"webpack:///./lib/adapters/xhr.js",
"webpack:///./lib/core/settle.js",
"webpack:///./lib/core/createError.js",
"webpack:///./lib/core/enhanceError.js",
"webpack:///./lib/helpers/buildURL.js",
"webpack:///./lib/helpers/parseHeaders.js",
"webpack:///./lib/helpers/isURLSameOrigin.js",
"webpack:///./lib/helpers/btoa.js",
"webpack:///./lib/helpers/cookies.js",
"webpack:///./lib/core/InterceptorManager.js",
"webpack:///./lib/core/dispatchRequest.js",
"webpack:///./lib/core/transformData.js",
"webpack:///./lib/cancel/isCancel.js",
"webpack:///./lib/helpers/isAbsoluteURL.js",
"webpack:///./lib/helpers/combineURLs.js",
"webpack:///./lib/cancel/Cancel.js",
"webpack:///./lib/cancel/CancelToken.js",
"webpack:///./lib/helpers/spread.js"
],
names: [
"root",
"factory",
"exports",
"module",
"define",
"amd",
"this",
"modules",
"__webpack_require__",
"moduleId",
"installedModules",
"id",
"loaded",
"call",
"m",
"c",
"p",
"createInstance",
"defaultConfig",
"context",
"Axios",
"instance",
"bind",
"prototype",
"request",
"utils",
"extend",
"defaults",
"axios",
"create",
"instanceConfig",
"merge",
"Cancel",
"CancelToken",
"isCancel",
"all",
"promises",
"Promise",
"spread",
"default",
"Buffer",
"isArray",
"val",
"toString",
"isBuffer",
"isArrayBuffer",
"isFormData",
"FormData",
"isArrayBufferView",
"result",
"ArrayBuffer",
"isView",
"buffer",
"isString",
"isNumber",
"isUndefined",
"isObject",
"isDate",
"isFile",
"isBlob",
"isFunction",
"isStream",
"pipe",
"isURLSearchParams",
"URLSearchParams",
"trim",
"str",
"replace",
"isStandardBrowserEnv",
"navigator",
"product",
"window",
"document",
"forEach",
"obj",
"fn",
"i",
"l",
"length",
"key",
"Object",
"hasOwnProperty",
"assignValue",
"arguments",
"a",
"b",
"thisArg",
"global",
"typedArraySupport",
"arr",
"Uint8Array",
"__proto__",
"foo",
"subarray",
"byteLength",
"e",
"kMaxLength",
"TYPED_ARRAY_SUPPORT",
"createBuffer",
"that",
"RangeError",
"arg",
"encodingOrOffset",
"Error",
"allocUnsafe",
"from",
"value",
"TypeError",
"fromArrayBuffer",
"fromString",
"fromObject",
"assertSize",
"size",
"alloc",
"fill",
"encoding",
"undefined",
"checked",
"string",
"isEncoding",
"actual",
"write",
"slice",
"fromArrayLike",
"array",
"byteOffset",
"len",
"copy",
"isnan",
"type",
"data",
"SlowBuffer",
"loweredCase",
"utf8ToBytes",
"base64ToBytes",
"toLowerCase",
"slowToString",
"start",
"end",
"hexSlice",
"utf8Slice",
"asciiSlice",
"latin1Slice",
"base64Slice",
"utf16leSlice",
"swap",
"n",
"bidirectionalIndexOf",
"dir",
"isNaN",
"arrayIndexOf",
"indexOf",
"lastIndexOf",
"read",
"buf",
"indexSize",
"readUInt16BE",
"arrLength",
"valLength",
"String",
"foundIndex",
"found",
"j",
"hexWrite",
"offset",
"Number",
"remaining",
"strLen",
"parsed",
"parseInt",
"substr",
"utf8Write",
"blitBuffer",
"asciiWrite",
"asciiToBytes",
"latin1Write",
"base64Write",
"ucs2Write",
"utf16leToBytes",
"base64",
"fromByteArray",
"Math",
"min",
"res",
"firstByte",
"codePoint",
"bytesPerSequence",
"secondByte",
"thirdByte",
"fourthByte",
"tempCodePoint",
"push",
"decodeCodePointsArray",
"codePoints",
"MAX_ARGUMENTS_LENGTH",
"fromCharCode",
"apply",
"ret",
"out",
"toHex",
"bytes",
"checkOffset",
"ext",
"checkInt",
"max",
"objectWriteUInt16",
"littleEndian",
"objectWriteUInt32",
"checkIEEE754",
"writeFloat",
"noAssert",
"ieee754",
"writeDouble",
"base64clean",
"stringtrim",
"INVALID_BASE64_RE",
"units",
"Infinity",
"leadSurrogate",
"charCodeAt",
"byteArray",
"hi",
"lo",
"toByteArray",
"src",
"dst",
"INSPECT_MAX_BYTES",
"poolSize",
"_augment",
"Symbol",
"species",
"defineProperty",
"configurable",
"allocUnsafeSlow",
"_isBuffer",
"compare",
"x",
"y",
"concat",
"list",
"pos",
"swap16",
"swap32",
"swap64",
"equals",
"inspect",
"match",
"join",
"target",
"thisStart",
"thisEnd",
"thisCopy",
"targetCopy",
"includes",
"isFinite",
"toJSON",
"Array",
"_arr",
"newBuf",
"sliceLen",
"readUIntLE",
"mul",
"readUIntBE",
"readUInt8",
"readUInt16LE",
"readUInt32LE",
"readUInt32BE",
"readIntLE",
"pow",
"readIntBE",
"readInt8",
"readInt16LE",
"readInt16BE",
"readInt32LE",
"readInt32BE",
"readFloatLE",
"readFloatBE",
"readDoubleLE",
"readDoubleBE",
"writeUIntLE",
"maxBytes",
"writeUIntBE",
"writeUInt8",
"floor",
"writeUInt16LE",
"writeUInt16BE",
"writeUInt32LE",
"writeUInt32BE",
"writeIntLE",
"limit",
"sub",
"writeIntBE",
"writeInt8",
"writeInt16LE",
"writeInt16BE",
"writeInt32LE",
"writeInt32BE",
"writeFloatLE",
"writeFloatBE",
"writeDoubleLE",
"writeDoubleBE",
"targetStart",
"set",
"code",
"placeHoldersCount",
"b64",
"tmp",
"placeHolders",
"Arr",
"L",
"revLookup",
"tripletToBase64",
"num",
"lookup",
"encodeChunk",
"uint8",
"output",
"extraBytes",
"parts",
"maxChunkLength",
"len2",
"isLE",
"mLen",
"nBytes",
"eLen",
"eMax",
"eBias",
"nBits",
"d",
"s",
"NaN",
"rt",
"abs",
"log",
"LN2",
"args",
"interceptors",
"InterceptorManager",
"response",
"dispatchRequest",
"isAbsoluteURL",
"combineURLs",
"config",
"url",
"method",
"baseURL",
"chain",
"promise",
"resolve",
"interceptor",
"unshift",
"fulfilled",
"rejected",
"then",
"shift",
"setContentTypeIfUnset",
"headers",
"getDefaultAdapter",
"adapter",
"XMLHttpRequest",
"process",
"normalizeHeaderName",
"DEFAULT_CONTENT_TYPE",
"Content-Type",
"transformRequest",
"JSON",
"stringify",
"transformResponse",
"parse",
"timeout",
"xsrfCookieName",
"xsrfHeaderName",
"maxContentLength",
"validateStatus",
"status",
"common",
"Accept",
"normalizedName",
"name",
"toUpperCase",
"settle",
"buildURL",
"parseHeaders",
"isURLSameOrigin",
"createError",
"btoa",
"reject",
"requestData",
"requestHeaders",
"loadEvent",
"xDomain",
"XDomainRequest",
"onprogress",
"ontimeout",
"auth",
"username",
"password",
"Authorization",
"open",
"params",
"paramsSerializer",
"readyState",
"responseURL",
"responseHeaders",
"getAllResponseHeaders",
"responseData",
"responseType",
"responseText",
"statusText",
"onerror",
"cookies",
"xsrfValue",
"withCredentials",
"setRequestHeader",
"onDownloadProgress",
"addEventListener",
"onUploadProgress",
"upload",
"cancelToken",
"cancel",
"abort",
"send",
"enhanceError",
"message",
"error",
"encode",
"encodeURIComponent",
"serializedParams",
"v",
"toISOString",
"split",
"line",
"resolveURL",
"href",
"msie",
"urlParsingNode",
"setAttribute",
"protocol",
"host",
"search",
"hash",
"hostname",
"port",
"pathname",
"charAt",
"originURL",
"test",
"userAgent",
"createElement",
"location",
"requestURL",
"E",
"input",
"block",
"charCode",
"idx",
"map",
"chars",
"expires",
"path",
"domain",
"secure",
"cookie",
"Date",
"toGMTString",
"RegExp",
"decodeURIComponent",
"remove",
"now",
"handlers",
"use",
"eject",
"h",
"throwIfCancellationRequested",
"throwIfRequested",
"transformData",
"reason",
"fns",
"__CANCEL__",
"relativeURL",
"executor",
"resolvePromise",
"token",
"source",
"callback"
],
mappings: "CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,MAAAD,IAEAD,EAAA,MAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GEtDhCL,EAAAD,QAAAM,EAAA,IF4DM,SAASL,EAAQD,EAASM,GG5DhC,YAaA,SAAAS,GAAAC,GACA,GAAAC,GAAA,GAAAC,GAAAF,GACAG,EAAAC,EAAAF,EAAAG,UAAAC,QAAAL,EAQA,OALAM,GAAAC,OAAAL,EAAAD,EAAAG,UAAAJ,GAGAM,EAAAC,OAAAL,EAAAF,GAEAE,EArBA,GAAAI,GAAAjB,EAAA,GACAc,EAAAd,EAAA,GACAY,EAAAZ,EAAA,GACAmB,EAAAnB,EAAA,GAsBAoB,EAAAX,EAAAU,EAGAC,GAAAR,QAGAQ,EAAAC,OAAA,SAAAC,GACA,MAAAb,GAAAQ,EAAAM,MAAAJ,EAAAG,KAIAF,EAAAI,OAAAxB,EAAA,IACAoB,EAAAK,YAAAzB,EAAA,IACAoB,EAAAM,SAAA1B,EAAA,IAGAoB,EAAAO,IAAA,SAAAC,GACA,MAAAC,SAAAF,IAAAC,IAEAR,EAAAU,OAAA9B,EAAA,IAEAL,EAAAD,QAAA0B,EAGAzB,EAAAD,QAAAqC,QAAAX,GHmEM,SAASzB,EAAQD,EAASM,IItHhC,SAAAgC,GAAA,YAgBA,SAAAC,GAAAC,GACA,yBAAAC,EAAA9B,KAAA6B,GASA,QAAAE,GAAAF,GACA,yBAAAF,MAAA,UAAAA,EAAAI,SAAAF,GASA,QAAAG,GAAAH,GACA,+BAAAC,EAAA9B,KAAA6B,GASA,QAAAI,GAAAJ,GACA,yBAAAK,WAAAL,YAAAK,UASA,QAAAC,GAAAN,GACA,GAAAO,EAMA,OAJAA,GADA,mBAAAC,0BAAA,OACAA,YAAAC,OAAAT,GAEA,GAAAA,EAAA,QAAAA,EAAAU,iBAAAF,aAWA,QAAAG,GAAAX,GACA,sBAAAA,GASA,QAAAY,GAAAZ,GACA,sBAAAA,GASA,QAAAa,GAAAb,GACA,yBAAAA,GASA,QAAAc,GAAAd,GACA,cAAAA,GAAA,gBAAAA,GASA,QAAAe,GAAAf,GACA,wBAAAC,EAAA9B,KAAA6B,GASA,QAAAgB,GAAAhB,GACA,wBAAAC,EAAA9B,KAAA6B,GASA,QAAAiB,GAAAjB,GACA,wBAAAC,EAAA9B,KAAA6B,GASA,QAAAkB,GAAAlB,GACA,4BAAAC,EAAA9B,KAAA6B,GASA,QAAAmB,GAAAnB,GACA,MAAAc,GAAAd,IAAAkB,EAAAlB,EAAAoB,MASA,QAAAC,GAAArB,GACA,yBAAAsB,kBAAAtB,YAAAsB,iBASA,QAAAC,GAAAC,GACA,MAAAA,GAAAC,QAAA,WAAAA,QAAA,WAgBA,QAAAC,KACA,0BAAAC,YAAA,gBAAAA,UAAAC,WAIA,mBAAAC,SACA,mBAAAC,WAgBA,QAAAC,GAAAC,EAAAC,GAEA,UAAAD,GAAA,mBAAAA,GAUA,GALA,gBAAAA,IAAAjC,EAAAiC,KAEAA,OAGAjC,EAAAiC,GAEA,OAAAE,GAAA,EAAAC,EAAAH,EAAAI,OAAmCF,EAAAC,EAAOD,IAC1CD,EAAA9D,KAAA,KAAA6D,EAAAE,KAAAF,OAIA,QAAAK,KAAAL,GACAM,OAAAzD,UAAA0D,eAAApE,KAAA6D,EAAAK,IACAJ,EAAA9D,KAAA,KAAA6D,EAAAK,KAAAL,GAuBA,QAAA3C,KAEA,QAAAmD,GAAAxC,EAAAqC,GACA,gBAAA9B,GAAA8B,IAAA,gBAAArC,GACAO,EAAA8B,GAAAhD,EAAAkB,EAAA8B,GAAArC,GAEAO,EAAA8B,GAAArC,EAIA,OATAO,MASA2B,EAAA,EAAAC,EAAAM,UAAAL,OAAuCF,EAAAC,EAAOD,IAC9CH,EAAAU,UAAAP,GAAAM,EAEA,OAAAjC,GAWA,QAAAvB,GAAA0D,EAAAC,EAAAC,GAQA,MAPAb,GAAAY,EAAA,SAAA3C,EAAAqC,GACAO,GAAA,kBAAA5C,GACA0C,EAAAL,GAAAzD,EAAAoB,EAAA4C,GAEAF,EAAAL,GAAArC,IAGA0C,EA7RA,GAAA9D,GAAAd,EAAA,GAMAmC,EAAAqC,OAAAzD,UAAAoB,QA0RAxC,GAAAD,SACAuC,UACAI,gBACAD,WACAE,aACAE,oBACAK,WACAC,WACAE,WACAD,cACAE,SACAC,SACAC,SACAC,aACAC,WACAE,oBACAK,uBACAK,UACA1C,QACAL,SACAuC,UJ2H8BpD,KAAKX,EAASM,EAAoB,GAAGgC,SAI7D,SAASrC,EAAQD,EAASM,IKrbhC,SAAA+E;;;;;;AAQA,YA2CA,SAAAC,KACA,IACA,GAAAC,GAAA,GAAAC,YAAA,EAEA,OADAD,GAAAE,WAAqBA,UAAAD,WAAAnE,UAAAqE,IAAA,WAAmD,YACxE,KAAAH,EAAAG,OACA,kBAAAH,GAAAI,UACA,IAAAJ,EAAAI,SAAA,KAAAC,WACG,MAAAC,GACH,UAIA,QAAAC,KACA,MAAAxD,GAAAyD,oBACA,WACA,WAGA,QAAAC,GAAAC,EAAArB,GACA,GAAAkB,IAAAlB,EACA,SAAAsB,YAAA,6BAcA,OAZA5D,GAAAyD,qBAEAE,EAAA,GAAAT,YAAAZ,GACAqB,EAAAR,UAAAnD,EAAAjB,YAGA,OAAA4E,IACAA,EAAA,GAAA3D,GAAAsC,IAEAqB,EAAArB,UAGAqB,EAaA,QAAA3D,GAAA6D,EAAAC,EAAAxB,GACA,KAAAtC,EAAAyD,qBAAA3F,eAAAkC,IACA,UAAAA,GAAA6D,EAAAC,EAAAxB,EAIA,oBAAAuB,GAAA,CACA,mBAAAC,GACA,SAAAC,OACA,oEAGA,OAAAC,GAAAlG,KAAA+F,GAEA,MAAAI,GAAAnG,KAAA+F,EAAAC,EAAAxB,GAWA,QAAA2B,GAAAN,EAAAO,EAAAJ,EAAAxB,GACA,mBAAA4B,GACA,SAAAC,WAAA,wCAGA,0BAAAzD,cAAAwD,YAAAxD,aACA0D,EAAAT,EAAAO,EAAAJ,EAAAxB,GAGA,gBAAA4B,GACAG,EAAAV,EAAAO,EAAAJ,GAGAQ,EAAAX,EAAAO,GA4BA,QAAAK,GAAAC,GACA,mBAAAA,GACA,SAAAL,WAAA,mCACG,IAAAK,EAAA,EACH,SAAAZ,YAAA,wCAIA,QAAAa,GAAAd,EAAAa,EAAAE,EAAAC,GAEA,MADAJ,GAAAC,GACAA,GAAA,EACAd,EAAAC,EAAAa,GAEAI,SAAAF,EAIA,gBAAAC,GACAjB,EAAAC,EAAAa,GAAAE,OAAAC,GACAjB,EAAAC,EAAAa,GAAAE,QAEAhB,EAAAC,EAAAa,GAWA,QAAAR,GAAAL,EAAAa,GAGA,GAFAD,EAAAC,GACAb,EAAAD,EAAAC,EAAAa,EAAA,MAAAK,EAAAL,KACAxE,EAAAyD,oBACA,OAAArB,GAAA,EAAmBA,EAAAoC,IAAUpC,EAC7BuB,EAAAvB,GAAA,CAGA,OAAAuB,GAgBA,QAAAU,GAAAV,EAAAmB,EAAAH,GAKA,GAJA,gBAAAA,IAAA,KAAAA,IACAA,EAAA,SAGA3E,EAAA+E,WAAAJ,GACA,SAAAR,WAAA,6CAGA,IAAA7B,GAAA,EAAAgB,EAAAwB,EAAAH,EACAhB,GAAAD,EAAAC,EAAArB,EAEA,IAAA0C,GAAArB,EAAAsB,MAAAH,EAAAH,EASA,OAPAK,KAAA1C,IAIAqB,IAAAuB,MAAA,EAAAF,IAGArB,EAGA,QAAAwB,GAAAxB,EAAAyB,GACA,GAAA9C,GAAA8C,EAAA9C,OAAA,MAAAuC,EAAAO,EAAA9C,OACAqB,GAAAD,EAAAC,EAAArB,EACA,QAAAF,GAAA,EAAiBA,EAAAE,EAAYF,GAAA,EAC7BuB,EAAAvB,GAAA,IAAAgD,EAAAhD,EAEA,OAAAuB,GAGA,QAAAS,GAAAT,EAAAyB,EAAAC,EAAA/C,GAGA,GAFA8C,EAAA9B,WAEA+B,EAAA,GAAAD,EAAA9B,WAAA+B,EACA,SAAAzB,YAAA,4BAGA,IAAAwB,EAAA9B,WAAA+B,GAAA/C,GAAA,GACA,SAAAsB,YAAA,4BAmBA,OAfAwB,GADAR,SAAAS,GAAAT,SAAAtC,EACA,GAAAY,YAAAkC,GACGR,SAAAtC,EACH,GAAAY,YAAAkC,EAAAC,GAEA,GAAAnC,YAAAkC,EAAAC,EAAA/C,GAGAtC,EAAAyD,qBAEAE,EAAAyB,EACAzB,EAAAR,UAAAnD,EAAAjB,WAGA4E,EAAAwB,EAAAxB,EAAAyB,GAEAzB,EAGA,QAAAW,GAAAX,EAAAzB,GACA,GAAAlC,EAAAI,SAAA8B,GAAA,CACA,GAAAoD,GAAA,EAAAT,EAAA3C,EAAAI,OAGA,OAFAqB,GAAAD,EAAAC,EAAA2B,GAEA,IAAA3B,EAAArB,OACAqB,GAGAzB,EAAAqD,KAAA5B,EAAA,IAAA2B,GACA3B,GAGA,GAAAzB,EAAA,CACA,sBAAAxB,cACAwB,EAAAtB,iBAAAF,cAAA,UAAAwB,GACA,sBAAAA,GAAAI,QAAAkD,EAAAtD,EAAAI,QACAoB,EAAAC,EAAA,GAEAwB,EAAAxB,EAAAzB,EAGA,eAAAA,EAAAuD,MAAAxF,EAAAiC,EAAAwD,MACA,MAAAP,GAAAxB,EAAAzB,EAAAwD,MAIA,SAAAvB,WAAA,sFAGA,QAAAU,GAAAvC,GAGA,GAAAA,GAAAkB,IACA,SAAAI,YAAA,0DACAJ,IAAArD,SAAA,aAEA,UAAAmC,EAGA,QAAAqD,GAAArD,GAIA,OAHAA,OACAA,EAAA,GAEAtC,EAAAyE,OAAAnC,GA+EA,QAAAgB,GAAAwB,EAAAH,GACA,GAAA3E,EAAAI,SAAA0E,GACA,MAAAA,GAAAxC,MAEA,uBAAA5B,cAAA,kBAAAA,aAAAC,SACAD,YAAAC,OAAAmE,gBAAApE,cACA,MAAAoE,GAAAxB,UAEA,iBAAAwB,KACAA,EAAA,GAAAA,EAGA,IAAAQ,GAAAR,EAAAxC,MACA,QAAAgD,EAAA,QAIA,KADA,GAAAM,IAAA,IAEA,OAAAjB,GACA,YACA,aACA,aACA,MAAAW,EACA,YACA,YACA,IAAAV,QACA,MAAAiB,GAAAf,GAAAxC,MACA,YACA,YACA,cACA,eACA,SAAAgD,CACA,WACA,MAAAA,KAAA,CACA,cACA,MAAAQ,GAAAhB,GAAAxC,MACA,SACA,GAAAsD,EAAA,MAAAC,GAAAf,GAAAxC,MACAqC,IAAA,GAAAA,GAAAoB,cACAH,GAAA,GAMA,QAAAI,GAAArB,EAAAsB,EAAAC,GACA,GAAAN,IAAA,CAcA,KALAhB,SAAAqB,KAAA,KACAA,EAAA,GAIAA,EAAAnI,KAAAwE,OACA,QAOA,KAJAsC,SAAAsB,KAAApI,KAAAwE,UACA4D,EAAApI,KAAAwE,QAGA4D,GAAA,EACA,QAOA,IAHAA,KAAA,EACAD,KAAA,EAEAC,GAAAD,EACA,QAKA,KAFAtB,MAAA,UAGA,OAAAA,GACA,UACA,MAAAwB,GAAArI,KAAAmI,EAAAC,EAEA,YACA,YACA,MAAAE,GAAAtI,KAAAmI,EAAAC,EAEA,aACA,MAAAG,GAAAvI,KAAAmI,EAAAC,EAEA,cACA,aACA,MAAAI,GAAAxI,KAAAmI,EAAAC,EAEA,cACA,MAAAK,GAAAzI,KAAAmI,EAAAC,EAEA,YACA,YACA,cACA,eACA,MAAAM,GAAA1I,KAAAmI,EAAAC,EAEA,SACA,GAAAN,EAAA,SAAAzB,WAAA,qBAAAQ,EACAA,MAAA,IAAAoB,cACAH,GAAA,GASA,QAAAa,GAAA5D,EAAA6D,EAAApI,GACA,GAAA8D,GAAAS,EAAA6D,EACA7D,GAAA6D,GAAA7D,EAAAvE,GACAuE,EAAAvE,GAAA8D,EAmIA,QAAAuE,GAAA/F,EAAAV,EAAAmF,EAAAV,EAAAiC,GAEA,OAAAhG,EAAA0B,OAAA,QAmBA,IAhBA,gBAAA+C,IACAV,EAAAU,EACAA,EAAA,GACGA,EAAA,WACHA,EAAA,WACGA,GAAA,aACHA,GAAA,YAEAA,KACAwB,MAAAxB,KAEAA,EAAAuB,EAAA,EAAAhG,EAAA0B,OAAA,GAIA+C,EAAA,IAAAA,EAAAzE,EAAA0B,OAAA+C,GACAA,GAAAzE,EAAA0B,OAAA,CACA,GAAAsE,EAAA,QACAvB,GAAAzE,EAAA0B,OAAA,MACG,IAAA+C,EAAA,GACH,IAAAuB,EACA,QADAvB,GAAA,EAUA,GALA,gBAAAnF,KACAA,EAAAF,EAAAiE,KAAA/D,EAAAyE,IAIA3E,EAAAI,SAAAF,GAEA,WAAAA,EAAAoC,QACA,EAEAwE,EAAAlG,EAAAV,EAAAmF,EAAAV,EAAAiC,EACG,oBAAA1G,GAEH,MADAA,IAAA,IACAF,EAAAyD,qBACA,kBAAAP,YAAAnE,UAAAgI,QACAH,EACA1D,WAAAnE,UAAAgI,QAAA1I,KAAAuC,EAAAV,EAAAmF,GAEAnC,WAAAnE,UAAAiI,YAAA3I,KAAAuC,EAAAV,EAAAmF,GAGAyB,EAAAlG,GAAAV,GAAAmF,EAAAV,EAAAiC,EAGA,UAAAzC,WAAA,wCAGA,QAAA2C,GAAA7D,EAAA/C,EAAAmF,EAAAV,EAAAiC,GAmBA,QAAAK,GAAAC,EAAA9E,GACA,WAAA+E,EACAD,EAAA9E,GAEA8E,EAAAE,aAAAhF,EAAA+E,GAtBA,GAAAA,GAAA,EACAE,EAAApE,EAAAX,OACAgF,EAAApH,EAAAoC,MAEA,IAAAsC,SAAAD,IACAA,EAAA4C,OAAA5C,GAAAoB,cACA,SAAApB,GAAA,UAAAA,GACA,YAAAA,GAAA,aAAAA,GAAA,CACA,GAAA1B,EAAAX,OAAA,GAAApC,EAAAoC,OAAA,EACA,QAEA6E,GAAA,EACAE,GAAA,EACAC,GAAA,EACAjC,GAAA,EAYA,GAAAjD,EACA,IAAAwE,EAAA,CACA,GAAAY,IAAA,CACA,KAAApF,EAAAiD,EAAwBjD,EAAAiF,EAAejF,IACvC,GAAA6E,EAAAhE,EAAAb,KAAA6E,EAAA/G,EAAAsH,KAAA,IAAApF,EAAAoF,IAEA,GADAA,KAAA,IAAAA,EAAApF,GACAA,EAAAoF,EAAA,IAAAF,EAAA,MAAAE,GAAAL,MAEAK,MAAA,IAAApF,KAAAoF,GACAA,GAAA,MAKA,KADAnC,EAAAiC,EAAAD,IAAAhC,EAAAgC,EAAAC,GACAlF,EAAAiD,EAAwBjD,GAAA,EAAQA,IAAA,CAEhC,OADAqF,IAAA,EACAC,EAAA,EAAqBA,EAAAJ,EAAeI,IACpC,GAAAT,EAAAhE,EAAAb,EAAAsF,KAAAT,EAAA/G,EAAAwH,GAAA,CACAD,GAAA,CACA,OAGA,GAAAA,EAAA,MAAArF,GAIA,SAeA,QAAAuF,GAAAT,EAAApC,EAAA8C,EAAAtF,GACAsF,EAAAC,OAAAD,IAAA,CACA,IAAAE,GAAAZ,EAAA5E,OAAAsF,CACAtF,IAGAA,EAAAuF,OAAAvF,GACAA,EAAAwF,IACAxF,EAAAwF,IAJAxF,EAAAwF,CASA,IAAAC,GAAAjD,EAAAxC,MACA,IAAAyF,EAAA,eAAA5D,WAAA,qBAEA7B,GAAAyF,EAAA,IACAzF,EAAAyF,EAAA,EAEA,QAAA3F,GAAA,EAAiBA,EAAAE,IAAYF,EAAA,CAC7B,GAAA4F,GAAAC,SAAAnD,EAAAoD,OAAA,EAAA9F,EAAA,MACA,IAAAyE,MAAAmB,GAAA,MAAA5F,EACA8E,GAAAU,EAAAxF,GAAA4F,EAEA,MAAA5F,GAGA,QAAA+F,GAAAjB,EAAApC,EAAA8C,EAAAtF,GACA,MAAA8F,GAAAvC,EAAAf,EAAAoC,EAAA5E,OAAAsF,GAAAV,EAAAU,EAAAtF,GAGA,QAAA+F,GAAAnB,EAAApC,EAAA8C,EAAAtF,GACA,MAAA8F,GAAAE,EAAAxD,GAAAoC,EAAAU,EAAAtF,GAGA,QAAAiG,GAAArB,EAAApC,EAAA8C,EAAAtF,GACA,MAAA+F,GAAAnB,EAAApC,EAAA8C,EAAAtF,GAGA,QAAAkG,GAAAtB,EAAApC,EAAA8C,EAAAtF,GACA,MAAA8F,GAAAtC,EAAAhB,GAAAoC,EAAAU,EAAAtF,GAGA,QAAAmG,GAAAvB,EAAApC,EAAA8C,EAAAtF,GACA,MAAA8F,GAAAM,EAAA5D,EAAAoC,EAAA5E,OAAAsF,GAAAV,EAAAU,EAAAtF,GAkFA,QAAAiE,GAAAW,EAAAjB,EAAAC,GACA,WAAAD,GAAAC,IAAAgB,EAAA5E,OACAqG,EAAAC,cAAA1B,GAEAyB,EAAAC,cAAA1B,EAAAhC,MAAAe,EAAAC,IAIA,QAAAE,GAAAc,EAAAjB,EAAAC,GACAA,EAAA2C,KAAAC,IAAA5B,EAAA5E,OAAA4D,EAIA,KAHA,GAAA6C,MAEA3G,EAAA6D,EACA7D,EAAA8D,GAAA,CACA,GAAA8C,GAAA9B,EAAA9E,GACA6G,EAAA,KACAC,EAAAF,EAAA,MACAA,EAAA,MACAA,EAAA,MACA,CAEA,IAAA5G,EAAA8G,GAAAhD,EAAA,CACA,GAAAiD,GAAAC,EAAAC,EAAAC,CAEA,QAAAJ,GACA,OACAF,EAAA,MACAC,EAAAD,EAEA,MACA,QACAG,EAAAjC,EAAA9E,EAAA,GACA,WAAA+G,KACAG,GAAA,GAAAN,IAAA,KAAAG,EACAG,EAAA,MACAL,EAAAK,GAGA,MACA,QACAH,EAAAjC,EAAA9E,EAAA,GACAgH,EAAAlC,EAAA9E,EAAA,GACA,WAAA+G,IAAA,WAAAC,KACAE,GAAA,GAAAN,IAAA,OAAAG,IAAA,KAAAC,EACAE,EAAA,OAAAA,EAAA,OAAAA,EAAA,SACAL,EAAAK,GAGA,MACA,QACAH,EAAAjC,EAAA9E,EAAA,GACAgH,EAAAlC,EAAA9E,EAAA,GACAiH,EAAAnC,EAAA9E,EAAA,GACA,WAAA+G,IAAA,WAAAC,IAAA,WAAAC,KACAC,GAAA,GAAAN,IAAA,OAAAG,IAAA,OAAAC,IAAA,KAAAC,EACAC,EAAA,OAAAA,EAAA,UACAL,EAAAK,KAMA,OAAAL,GAGAA,EAAA,MACAC,EAAA,GACKD,EAAA,QAELA,GAAA,MACAF,EAAAQ,KAAAN,IAAA,eACAA,EAAA,WAAAA,GAGAF,EAAAQ,KAAAN,GACA7G,GAAA8G,EAGA,MAAAM,GAAAT,GAQA,QAAAS,GAAAC,GACA,GAAAnE,GAAAmE,EAAAnH,MACA,IAAAgD,GAAAoE,GACA,MAAAnC,QAAAoC,aAAAC,MAAArC,OAAAkC,EAMA,KAFA,GAAAV,GAAA,GACA3G,EAAA,EACAA,EAAAkD,GACAyD,GAAAxB,OAAAoC,aAAAC,MACArC,OACAkC,EAAAvE,MAAA9C,KAAAsH,IAGA,OAAAX,GAGA,QAAA1C,GAAAa,EAAAjB,EAAAC,GACA,GAAA2D,GAAA,EACA3D,GAAA2C,KAAAC,IAAA5B,EAAA5E,OAAA4D,EAEA,QAAA9D,GAAA6D,EAAqB7D,EAAA8D,IAAS9D,EAC9ByH,GAAAtC,OAAAoC,aAAA,IAAAzC,EAAA9E,GAEA,OAAAyH,GAGA,QAAAvD,GAAAY,EAAAjB,EAAAC,GACA,GAAA2D,GAAA,EACA3D,GAAA2C,KAAAC,IAAA5B,EAAA5E,OAAA4D,EAEA,QAAA9D,GAAA6D,EAAqB7D,EAAA8D,IAAS9D,EAC9ByH,GAAAtC,OAAAoC,aAAAzC,EAAA9E,GAEA,OAAAyH,GAGA,QAAA1D,GAAAe,EAAAjB,EAAAC,GACA,GAAAZ,GAAA4B,EAAA5E,SAEA2D,KAAA,KAAAA,EAAA,KACAC,KAAA,GAAAA,EAAAZ,KAAAY,EAAAZ,EAGA,QADAwE,GAAA,GACA1H,EAAA6D,EAAqB7D,EAAA8D,IAAS9D,EAC9B0H,GAAAC,EAAA7C,EAAA9E,GAEA,OAAA0H,GAGA,QAAAtD,GAAAU,EAAAjB,EAAAC,GAGA,OAFA8D,GAAA9C,EAAAhC,MAAAe,EAAAC,GACA6C,EAAA,GACA3G,EAAA,EAAiBA,EAAA4H,EAAA1H,OAAkBF,GAAA,EACnC2G,GAAAxB,OAAAoC,aAAAK,EAAA5H,GAAA,IAAA4H,EAAA5H,EAAA,GAEA,OAAA2G,GA0CA,QAAAkB,GAAArC,EAAAsC,EAAA5H,GACA,GAAAsF,EAAA,OAAAA,EAAA,WAAAhE,YAAA,qBACA,IAAAgE,EAAAsC,EAAA5H,EAAA,SAAAsB,YAAA,yCA+JA,QAAAuG,GAAAjD,EAAAhD,EAAA0D,EAAAsC,EAAAE,EAAAtB,GACA,IAAA9I,EAAAI,SAAA8G,GAAA,SAAA/C,WAAA,8CACA,IAAAD,EAAAkG,GAAAlG,EAAA4E,EAAA,SAAAlF,YAAA,oCACA,IAAAgE,EAAAsC,EAAAhD,EAAA5E,OAAA,SAAAsB,YAAA,sBAkDA,QAAAyG,GAAAnD,EAAAhD,EAAA0D,EAAA0C,GACApG,EAAA,IAAAA,EAAA,MAAAA,EAAA,EACA,QAAA9B,GAAA,EAAAsF,EAAAmB,KAAAC,IAAA5B,EAAA5E,OAAAsF,EAAA,GAAuDxF,EAAAsF,IAAOtF,EAC9D8E,EAAAU,EAAAxF,IAAA8B,EAAA,QAAAoG,EAAAlI,EAAA,EAAAA,MACA,GAAAkI,EAAAlI,EAAA,EAAAA,GA8BA,QAAAmI,GAAArD,EAAAhD,EAAA0D,EAAA0C,GACApG,EAAA,IAAAA,EAAA,WAAAA,EAAA,EACA,QAAA9B,GAAA,EAAAsF,EAAAmB,KAAAC,IAAA5B,EAAA5E,OAAAsF,EAAA,GAAuDxF,EAAAsF,IAAOtF,EAC9D8E,EAAAU,EAAAxF,GAAA8B,IAAA,GAAAoG,EAAAlI,EAAA,EAAAA,GAAA,IAmJA,QAAAoI,GAAAtD,EAAAhD,EAAA0D,EAAAsC,EAAAE,EAAAtB,GACA,GAAAlB,EAAAsC,EAAAhD,EAAA5E,OAAA,SAAAsB,YAAA,qBACA,IAAAgE,EAAA,WAAAhE,YAAA,sBAGA,QAAA6G,GAAAvD,EAAAhD,EAAA0D,EAAA0C,EAAAI,GAKA,MAJAA,IACAF,EAAAtD,EAAAhD,EAAA0D,EAAA,gDAEA+C,EAAA1F,MAAAiC,EAAAhD,EAAA0D,EAAA0C,EAAA,MACA1C,EAAA,EAWA,QAAAgD,GAAA1D,EAAAhD,EAAA0D,EAAA0C,EAAAI,GAKA,MAJAA,IACAF,EAAAtD,EAAAhD,EAAA0D,EAAA,kDAEA+C,EAAA1F,MAAAiC,EAAAhD,EAAA0D,EAAA0C,EAAA,MACA1C,EAAA,EAgIA,QAAAiD,GAAAnJ,GAIA,GAFAA,EAAAoJ,EAAApJ,GAAAC,QAAAoJ,GAAA,IAEArJ,EAAAY,OAAA,UAEA,MAAAZ,EAAAY,OAAA,OACAZ,GAAA,GAEA,OAAAA,GAGA,QAAAoJ,GAAApJ,GACA,MAAAA,GAAAD,KAAAC,EAAAD,OACAC,EAAAC,QAAA,iBAGA,QAAAoI,GAAArD,GACA,MAAAA,GAAA,OAAAA,EAAAvG,SAAA,IACAuG,EAAAvG,SAAA,IAGA,QAAA0F,GAAAf,EAAAkG,GACAA,KAAAC,GAMA,QALAhC,GACA3G,EAAAwC,EAAAxC,OACA4I,EAAA,KACAlB,KAEA5H,EAAA,EAAiBA,EAAAE,IAAYF,EAAA,CAI7B,GAHA6G,EAAAnE,EAAAqG,WAAA/I,GAGA6G,EAAA,OAAAA,EAAA,OAEA,IAAAiC,EAAA,CAEA,GAAAjC,EAAA,QAEA+B,GAAA,OAAAhB,EAAAT,KAAA,YACA,UACS,GAAAnH,EAAA,IAAAE,EAAA,EAET0I,GAAA,OAAAhB,EAAAT,KAAA,YACA,UAIA2B,EAAAjC,CAEA,UAIA,GAAAA,EAAA,QACA+B,GAAA,OAAAhB,EAAAT,KAAA,aACA2B,EAAAjC,CACA,UAIAA,GAAAiC,EAAA,UAAAjC,EAAA,iBACKiC,KAELF,GAAA,OAAAhB,EAAAT,KAAA,YAMA,IAHA2B,EAAA,KAGAjC,EAAA,KACA,IAAA+B,GAAA,UACAhB,GAAAT,KAAAN,OACK,IAAAA,EAAA,MACL,IAAA+B,GAAA,UACAhB,GAAAT,KACAN,GAAA,MACA,GAAAA,EAAA,SAEK,IAAAA,EAAA,OACL,IAAA+B,GAAA,UACAhB,GAAAT,KACAN,GAAA,OACAA,GAAA,SACA,GAAAA,EAAA,SAEK,MAAAA,EAAA,SASL,SAAAlF,OAAA,qBARA,KAAAiH,GAAA,UACAhB,GAAAT,KACAN,GAAA,OACAA,GAAA,UACAA,GAAA,SACA,GAAAA,EAAA,MAOA,MAAAe,GAGA,QAAA1B,GAAA5G,GAEA,OADA0J,MACAhJ,EAAA,EAAiBA,EAAAV,EAAAY,SAAgBF,EAEjCgJ,EAAA7B,KAAA,IAAA7H,EAAAyJ,WAAA/I,GAEA,OAAAgJ,GAGA,QAAA1C,GAAAhH,EAAAsJ,GAGA,OAFAzM,GAAA8M,EAAAC,EACAF,KACAhJ,EAAA,EAAiBA,EAAAV,EAAAY,WACjB0I,GAAA,QADiC5I,EAGjC7D,EAAAmD,EAAAyJ,WAAA/I,GACAiJ,EAAA9M,GAAA,EACA+M,EAAA/M,EAAA,IACA6M,EAAA7B,KAAA+B,GACAF,EAAA7B,KAAA8B,EAGA,OAAAD,GAGA,QAAAtF,GAAApE,GACA,MAAAiH,GAAA4C,YAAAV,EAAAnJ,IAGA,QAAA0G,GAAAoD,EAAAC,EAAA7D,EAAAtF,GACA,OAAAF,GAAA,EAAiBA,EAAAE,KACjBF,EAAAwF,GAAA6D,EAAAnJ,QAAAF,GAAAoJ,EAAAlJ,UAD6BF,EAE7BqJ,EAAArJ,EAAAwF,GAAA4D,EAAApJ,EAEA,OAAAA,GAGA,QAAAoD,GAAAtF,GACA,MAAAA,OAjvDA,GAAAyI,GAAA3K,EAAA,GACA2M,EAAA3M,EAAA,GACAiC,EAAAjC,EAAA,EAEAN,GAAAsC,SACAtC,EAAAiI,aACAjI,EAAAgO,kBAAA,GA0BA1L,EAAAyD,oBAAAmB,SAAA7B,EAAAU,oBACAV,EAAAU,oBACAT,IAKAtF,EAAA8F,eAkEAxD,EAAA2L,SAAA,KAGA3L,EAAA4L,SAAA,SAAA3I,GAEA,MADAA,GAAAE,UAAAnD,EAAAjB,UACAkE,GA2BAjD,EAAAiE,KAAA,SAAAC,EAAAJ,EAAAxB,GACA,MAAA2B,GAAA,KAAAC,EAAAJ,EAAAxB,IAGAtC,EAAAyD,sBACAzD,EAAAjB,UAAAoE,UAAAD,WAAAnE,UACAiB,EAAAmD,UAAAD,WACA,mBAAA2I,gBAAAC,SACA9L,EAAA6L,OAAAC,WAAA9L,GAEAwC,OAAAuJ,eAAA/L,EAAA6L,OAAAC,SACA5H,MAAA,KACA8H,cAAA,KAiCAhM,EAAAyE,MAAA,SAAAD,EAAAE,EAAAC,GACA,MAAAF,GAAA,KAAAD,EAAAE,EAAAC,IAiBA3E,EAAAgE,YAAA,SAAAQ,GACA,MAAAR,GAAA,KAAAQ,IAKAxE,EAAAiM,gBAAA,SAAAzH,GACA,MAAAR,GAAA,KAAAQ,IAiHAxE,EAAAI,SAAA,SAAAyC,GACA,cAAAA,MAAAqJ,YAGAlM,EAAAmM,QAAA,SAAAvJ,EAAAC,GACA,IAAA7C,EAAAI,SAAAwC,KAAA5C,EAAAI,SAAAyC,GACA,SAAAsB,WAAA,4BAGA,IAAAvB,IAAAC,EAAA,QAKA,QAHAuJ,GAAAxJ,EAAAN,OACA+J,EAAAxJ,EAAAP,OAEAF,EAAA,EAAAkD,EAAAuD,KAAAC,IAAAsD,EAAAC,GAAuCjK,EAAAkD,IAASlD,EAChD,GAAAQ,EAAAR,KAAAS,EAAAT,GAAA,CACAgK,EAAAxJ,EAAAR,GACAiK,EAAAxJ,EAAAT,EACA,OAIA,MAAAgK,GAAAC,GAAA,EACAA,EAAAD,EAAA,EACA,GAGApM,EAAA+E,WAAA,SAAAJ,GACA,OAAA4C,OAAA5C,GAAAoB,eACA,UACA,WACA,YACA,YACA,aACA,aACA,aACA,WACA,YACA,cACA,eACA,QACA,SACA,WAIA/F,EAAAsM,OAAA,SAAAC,EAAAjK,GACA,IAAArC,EAAAsM,GACA,SAAApI,WAAA,8CAGA,QAAAoI,EAAAjK,OACA,MAAAtC,GAAAyE,MAAA,EAGA,IAAArC,EACA,IAAAwC,SAAAtC,EAEA,IADAA,EAAA,EACAF,EAAA,EAAeA,EAAAmK,EAAAjK,SAAiBF,EAChCE,GAAAiK,EAAAnK,GAAAE,MAIA,IAAA1B,GAAAZ,EAAAgE,YAAA1B,GACAkK,EAAA,CACA,KAAApK,EAAA,EAAaA,EAAAmK,EAAAjK,SAAiBF,EAAA,CAC9B,GAAA8E,GAAAqF,EAAAnK,EACA,KAAApC,EAAAI,SAAA8G,GACA,SAAA/C,WAAA,8CAEA+C,GAAA3B,KAAA3E,EAAA4L,GACAA,GAAAtF,EAAA5E,OAEA,MAAA1B,IA8CAZ,EAAAsD,aA0EAtD,EAAAjB,UAAAmN,WAAA,EAQAlM,EAAAjB,UAAA0N,OAAA,WACA,GAAAnH,GAAAxH,KAAAwE,MACA,IAAAgD,EAAA,MACA,SAAA1B,YAAA,4CAEA,QAAAxB,GAAA,EAAiBA,EAAAkD,EAASlD,GAAA,EAC1BqE,EAAA3I,KAAAsE,IAAA,EAEA,OAAAtE,OAGAkC,EAAAjB,UAAA2N,OAAA,WACA,GAAApH,GAAAxH,KAAAwE,MACA,IAAAgD,EAAA,MACA,SAAA1B,YAAA,4CAEA,QAAAxB,GAAA,EAAiBA,EAAAkD,EAASlD,GAAA,EAC1BqE,EAAA3I,KAAAsE,IAAA,GACAqE,EAAA3I,KAAAsE,EAAA,EAAAA,EAAA,EAEA,OAAAtE,OAGAkC,EAAAjB,UAAA4N,OAAA,WACA,GAAArH,GAAAxH,KAAAwE,MACA,IAAAgD,EAAA,MACA,SAAA1B,YAAA,4CAEA,QAAAxB,GAAA,EAAiBA,EAAAkD,EAASlD,GAAA,EAC1BqE,EAAA3I,KAAAsE,IAAA,GACAqE,EAAA3I,KAAAsE,EAAA,EAAAA,EAAA,GACAqE,EAAA3I,KAAAsE,EAAA,EAAAA,EAAA,GACAqE,EAAA3I,KAAAsE,EAAA,EAAAA,EAAA,EAEA,OAAAtE,OAGAkC,EAAAjB,UAAAoB,SAAA,WACA,GAAAmC,GAAA,EAAAxE,KAAAwE,MACA,YAAAA,EAAA,GACA,IAAAK,UAAAL,OAAA8D,EAAAtI,KAAA,EAAAwE,GACA0D,EAAA4D,MAAA9L,KAAA6E,YAGA3C,EAAAjB,UAAA6N,OAAA,SAAA/J,GACA,IAAA7C,EAAAI,SAAAyC,GAAA,SAAAsB,WAAA,4BACA,OAAArG,QAAA+E,GACA,IAAA7C,EAAAmM,QAAArO,KAAA+E,IAGA7C,EAAAjB,UAAA8N,QAAA,WACA,GAAAnL,GAAA,GACA0I,EAAA1M,EAAAgO,iBAKA,OAJA5N,MAAAwE,OAAA,IACAZ,EAAA5D,KAAAqC,SAAA,QAAAiK,GAAA0C,MAAA,SAAkDC,KAAA,KAClDjP,KAAAwE,OAAA8H,IAAA1I,GAAA,UAEA,WAAAA,EAAA,KAGA1B,EAAAjB,UAAAoN,QAAA,SAAAa,EAAA/G,EAAAC,EAAA+G,EAAAC,GACA,IAAAlN,EAAAI,SAAA4M,GACA,SAAA7I,WAAA,4BAgBA,IAbAS,SAAAqB,IACAA,EAAA,GAEArB,SAAAsB,IACAA,EAAA8G,IAAA1K,OAAA,GAEAsC,SAAAqI,IACAA,EAAA,GAEArI,SAAAsI,IACAA,EAAApP,KAAAwE,QAGA2D,EAAA,GAAAC,EAAA8G,EAAA1K,QAAA2K,EAAA,GAAAC,EAAApP,KAAAwE,OACA,SAAAsB,YAAA,qBAGA,IAAAqJ,GAAAC,GAAAjH,GAAAC,EACA,QAEA,IAAA+G,GAAAC,EACA,QAEA,IAAAjH,GAAAC,EACA,QAQA,IALAD,KAAA,EACAC,KAAA,EACA+G,KAAA,EACAC,KAAA,EAEApP,OAAAkP,EAAA,QASA,QAPAZ,GAAAc,EAAAD,EACAZ,EAAAnG,EAAAD,EACAX,EAAAuD,KAAAC,IAAAsD,EAAAC,GAEAc,EAAArP,KAAAoH,MAAA+H,EAAAC,GACAE,EAAAJ,EAAA9H,MAAAe,EAAAC,GAEA9D,EAAA,EAAiBA,EAAAkD,IAASlD,EAC1B,GAAA+K,EAAA/K,KAAAgL,EAAAhL,GAAA,CACAgK,EAAAe,EAAA/K,GACAiK,EAAAe,EAAAhL,EACA,OAIA,MAAAgK,GAAAC,GAAA,EACAA,EAAAD,EAAA,EACA,GA6HApM,EAAAjB,UAAAsO,SAAA,SAAAnN,EAAAmF,EAAAV,GACA,MAAA7G,MAAAiJ,QAAA7G,EAAAmF,EAAAV,MAAA,GAGA3E,EAAAjB,UAAAgI,QAAA,SAAA7G,EAAAmF,EAAAV,GACA,MAAAgC,GAAA7I,KAAAoC,EAAAmF,EAAAV,GAAA,IAGA3E,EAAAjB,UAAAiI,YAAA,SAAA9G,EAAAmF,EAAAV,GACA,MAAAgC,GAAA7I,KAAAoC,EAAAmF,EAAAV,GAAA,IAkDA3E,EAAAjB,UAAAkG,MAAA,SAAAH,EAAA8C,EAAAtF,EAAAqC,GAEA,GAAAC,SAAAgD,EACAjD,EAAA,OACArC,EAAAxE,KAAAwE,OACAsF,EAAA,MAEG,IAAAhD,SAAAtC,GAAA,gBAAAsF,GACHjD,EAAAiD,EACAtF,EAAAxE,KAAAwE,OACAsF,EAAA,MAEG,KAAA0F,SAAA1F,GAWH,SAAA7D,OACA,0EAXA6D,IAAA,EACA0F,SAAAhL,IACAA,GAAA,EACAsC,SAAAD,MAAA,UAEAA,EAAArC,EACAA,EAAAsC,QASA,GAAAkD,GAAAhK,KAAAwE,OAAAsF,CAGA,KAFAhD,SAAAtC,KAAAwF,KAAAxF,EAAAwF,GAEAhD,EAAAxC,OAAA,IAAAA,EAAA,GAAAsF,EAAA,IAAAA,EAAA9J,KAAAwE,OACA,SAAAsB,YAAA,yCAGAe,OAAA,OAGA,KADA,GAAAiB,IAAA,IAEA,OAAAjB,GACA,UACA,MAAAgD,GAAA7J,KAAAgH,EAAA8C,EAAAtF,EAEA,YACA,YACA,MAAA6F,GAAArK,KAAAgH,EAAA8C,EAAAtF,EAEA,aACA,MAAA+F,GAAAvK,KAAAgH,EAAA8C,EAAAtF,EAEA,cACA,aACA,MAAAiG,GAAAzK,KAAAgH,EAAA8C,EAAAtF,EAEA,cAEA,MAAAkG,GAAA1K,KAAAgH,EAAA8C,EAAAtF,EAEA,YACA,YACA,cACA,eACA,MAAAmG,GAAA3K,KAAAgH,EAAA8C,EAAAtF,EAEA,SACA,GAAAsD,EAAA,SAAAzB,WAAA,qBAAAQ,EACAA,IAAA,GAAAA,GAAAoB,cACAH,GAAA,IAKA5F,EAAAjB,UAAAwO,OAAA,WACA,OACA9H,KAAA,SACAC,KAAA8H,MAAAzO,UAAAmG,MAAA7G,KAAAP,KAAA2P,MAAA3P,KAAA,IAwFA,IAAA4L,IAAA,IA8DA1J,GAAAjB,UAAAmG,MAAA,SAAAe,EAAAC,GACA,GAAAZ,GAAAxH,KAAAwE,MACA2D,OACAC,EAAAtB,SAAAsB,EAAAZ,IAAAY,EAEAD,EAAA,GACAA,GAAAX,EACAW,EAAA,IAAAA,EAAA,IACGA,EAAAX,IACHW,EAAAX,GAGAY,EAAA,GACAA,GAAAZ,EACAY,EAAA,IAAAA,EAAA,IACGA,EAAAZ,IACHY,EAAAZ,GAGAY,EAAAD,IAAAC,EAAAD,EAEA,IAAAyH,EACA,IAAA1N,EAAAyD,oBACAiK,EAAA5P,KAAAuF,SAAA4C,EAAAC,GACAwH,EAAAvK,UAAAnD,EAAAjB,cACG,CACH,GAAA4O,GAAAzH,EAAAD,CACAyH,GAAA,GAAA1N,GAAA2N,EAAA/I,OACA,QAAAxC,GAAA,EAAmBA,EAAAuL,IAAcvL,EACjCsL,EAAAtL,GAAAtE,KAAAsE,EAAA6D,GAIA,MAAAyH,IAWA1N,EAAAjB,UAAA6O,WAAA,SAAAhG,EAAAtE,EAAAoH,GACA9C,GAAA,EACAtE,GAAA,EACAoH,GAAAT,EAAArC,EAAAtE,EAAAxF,KAAAwE,OAKA,KAHA,GAAApC,GAAApC,KAAA8J,GACAiG,EAAA,EACAzL,EAAA,IACAA,EAAAkB,IAAAuK,GAAA,MACA3N,GAAApC,KAAA8J,EAAAxF,GAAAyL,CAGA,OAAA3N,IAGAF,EAAAjB,UAAA+O,WAAA,SAAAlG,EAAAtE,EAAAoH,GACA9C,GAAA,EACAtE,GAAA,EACAoH,GACAT,EAAArC,EAAAtE,EAAAxF,KAAAwE,OAKA,KAFA,GAAApC,GAAApC,KAAA8J,IAAAtE,GACAuK,EAAA,EACAvK,EAAA,IAAAuK,GAAA,MACA3N,GAAApC,KAAA8J,IAAAtE,GAAAuK,CAGA,OAAA3N,IAGAF,EAAAjB,UAAAgP,UAAA,SAAAnG,EAAA8C,GAEA,MADAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QACAxE,KAAA8J,IAGA5H,EAAAjB,UAAAiP,aAAA,SAAApG,EAAA8C,GAEA,MADAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QACAxE,KAAA8J,GAAA9J,KAAA8J,EAAA,OAGA5H,EAAAjB,UAAAqI,aAAA,SAAAQ,EAAA8C,GAEA,MADAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QACAxE,KAAA8J,IAAA,EAAA9J,KAAA8J,EAAA,IAGA5H,EAAAjB,UAAAkP,aAAA,SAAArG,EAAA8C,GAGA,MAFAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,SAEAxE,KAAA8J,GACA9J,KAAA8J,EAAA,MACA9J,KAAA8J,EAAA,QACA,SAAA9J,KAAA8J,EAAA,IAGA5H,EAAAjB,UAAAmP,aAAA,SAAAtG,EAAA8C,GAGA,MAFAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QAEA,SAAAxE,KAAA8J,IACA9J,KAAA8J,EAAA,OACA9J,KAAA8J,EAAA,MACA9J,KAAA8J,EAAA,KAGA5H,EAAAjB,UAAAoP,UAAA,SAAAvG,EAAAtE,EAAAoH,GACA9C,GAAA,EACAtE,GAAA,EACAoH,GAAAT,EAAArC,EAAAtE,EAAAxF,KAAAwE,OAKA,KAHA,GAAApC,GAAApC,KAAA8J,GACAiG,EAAA,EACAzL,EAAA,IACAA,EAAAkB,IAAAuK,GAAA,MACA3N,GAAApC,KAAA8J,EAAAxF,GAAAyL,CAMA,OAJAA,IAAA,IAEA3N,GAAA2N,IAAA3N,GAAA2I,KAAAuF,IAAA,IAAA9K,IAEApD,GAGAF,EAAAjB,UAAAsP,UAAA,SAAAzG,EAAAtE,EAAAoH,GACA9C,GAAA,EACAtE,GAAA,EACAoH,GAAAT,EAAArC,EAAAtE,EAAAxF,KAAAwE,OAKA,KAHA,GAAAF,GAAAkB,EACAuK,EAAA,EACA3N,EAAApC,KAAA8J,IAAAxF,GACAA,EAAA,IAAAyL,GAAA,MACA3N,GAAApC,KAAA8J,IAAAxF,GAAAyL,CAMA,OAJAA,IAAA,IAEA3N,GAAA2N,IAAA3N,GAAA2I,KAAAuF,IAAA,IAAA9K,IAEApD,GAGAF,EAAAjB,UAAAuP,SAAA,SAAA1G,EAAA8C,GAEA,MADAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QACA,IAAAxE,KAAA8J,IACA,IAAA9J,KAAA8J,GAAA,MADA9J,KAAA8J,IAIA5H,EAAAjB,UAAAwP,YAAA,SAAA3G,EAAA8C,GACAA,GAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,OACA,IAAApC,GAAApC,KAAA8J,GAAA9J,KAAA8J,EAAA,KACA,cAAA1H,EAAA,WAAAA,KAGAF,EAAAjB,UAAAyP,YAAA,SAAA5G,EAAA8C,GACAA,GAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,OACA,IAAApC,GAAApC,KAAA8J,EAAA,GAAA9J,KAAA8J,IAAA,CACA,cAAA1H,EAAA,WAAAA,KAGAF,EAAAjB,UAAA0P,YAAA,SAAA7G,EAAA8C,GAGA,MAFAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QAEAxE,KAAA8J,GACA9J,KAAA8J,EAAA,MACA9J,KAAA8J,EAAA,OACA9J,KAAA8J,EAAA,QAGA5H,EAAAjB,UAAA2P,YAAA,SAAA9G,EAAA8C,GAGA,MAFAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QAEAxE,KAAA8J,IAAA,GACA9J,KAAA8J,EAAA,OACA9J,KAAA8J,EAAA,MACA9J,KAAA8J,EAAA,IAGA5H,EAAAjB,UAAA4P,YAAA,SAAA/G,EAAA8C,GAEA,MADAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QACAqI,EAAA1D,KAAAnJ,KAAA8J,GAAA,SAGA5H,EAAAjB,UAAA6P,YAAA,SAAAhH,EAAA8C,GAEA,MADAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QACAqI,EAAA1D,KAAAnJ,KAAA8J,GAAA,SAGA5H,EAAAjB,UAAA8P,aAAA,SAAAjH,EAAA8C,GAEA,MADAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QACAqI,EAAA1D,KAAAnJ,KAAA8J,GAAA,SAGA5H,EAAAjB,UAAA+P,aAAA,SAAAlH,EAAA8C,GAEA,MADAA,IAAAT,EAAArC,EAAA,EAAA9J,KAAAwE,QACAqI,EAAA1D,KAAAnJ,KAAA8J,GAAA,SASA5H,EAAAjB,UAAAgQ,YAAA,SAAA7K,EAAA0D,EAAAtE,EAAAoH,GAIA,GAHAxG,KACA0D,GAAA,EACAtE,GAAA,GACAoH,EAAA,CACA,GAAAsE,GAAAnG,KAAAuF,IAAA,IAAA9K,GAAA,CACA6G,GAAArM,KAAAoG,EAAA0D,EAAAtE,EAAA0L,EAAA,GAGA,GAAAnB,GAAA,EACAzL,EAAA,CAEA,KADAtE,KAAA8J,GAAA,IAAA1D,IACA9B,EAAAkB,IAAAuK,GAAA,MACA/P,KAAA8J,EAAAxF,GAAA8B,EAAA2J,EAAA,GAGA,OAAAjG,GAAAtE,GAGAtD,EAAAjB,UAAAkQ,YAAA,SAAA/K,EAAA0D,EAAAtE,EAAAoH,GAIA,GAHAxG,KACA0D,GAAA,EACAtE,GAAA,GACAoH,EAAA,CACA,GAAAsE,GAAAnG,KAAAuF,IAAA,IAAA9K,GAAA,CACA6G,GAAArM,KAAAoG,EAAA0D,EAAAtE,EAAA0L,EAAA,GAGA,GAAA5M,GAAAkB,EAAA,EACAuK,EAAA,CAEA,KADA/P,KAAA8J,EAAAxF,GAAA,IAAA8B,IACA9B,GAAA,IAAAyL,GAAA,MACA/P,KAAA8J,EAAAxF,GAAA8B,EAAA2J,EAAA,GAGA,OAAAjG,GAAAtE,GAGAtD,EAAAjB,UAAAmQ,WAAA,SAAAhL,EAAA0D,EAAA8C,GAMA,MALAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,SACA5H,EAAAyD,sBAAAS,EAAA2E,KAAAsG,MAAAjL,IACApG,KAAA8J,GAAA,IAAA1D,EACA0D,EAAA,GAWA5H,EAAAjB,UAAAqQ,cAAA,SAAAlL,EAAA0D,EAAA8C,GAUA,MATAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,WACA5H,EAAAyD,qBACA3F,KAAA8J,GAAA,IAAA1D,EACApG,KAAA8J,EAAA,GAAA1D,IAAA,GAEAmG,EAAAvM,KAAAoG,EAAA0D,GAAA,GAEAA,EAAA,GAGA5H,EAAAjB,UAAAsQ,cAAA,SAAAnL,EAAA0D,EAAA8C,GAUA,MATAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,WACA5H,EAAAyD,qBACA3F,KAAA8J,GAAA1D,IAAA,EACApG,KAAA8J,EAAA,OAAA1D,GAEAmG,EAAAvM,KAAAoG,EAAA0D,GAAA,GAEAA,EAAA,GAUA5H,EAAAjB,UAAAuQ,cAAA,SAAApL,EAAA0D,EAAA8C,GAYA,MAXAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,gBACA5H,EAAAyD,qBACA3F,KAAA8J,EAAA,GAAA1D,IAAA,GACApG,KAAA8J,EAAA,GAAA1D,IAAA,GACApG,KAAA8J,EAAA,GAAA1D,IAAA,EACApG,KAAA8J,GAAA,IAAA1D,GAEAqG,EAAAzM,KAAAoG,EAAA0D,GAAA,GAEAA,EAAA,GAGA5H,EAAAjB,UAAAwQ,cAAA,SAAArL,EAAA0D,EAAA8C,GAYA,MAXAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,gBACA5H,EAAAyD,qBACA3F,KAAA8J,GAAA1D,IAAA,GACApG,KAAA8J,EAAA,GAAA1D,IAAA,GACApG,KAAA8J,EAAA,GAAA1D,IAAA,EACApG,KAAA8J,EAAA,OAAA1D,GAEAqG,EAAAzM,KAAAoG,EAAA0D,GAAA,GAEAA,EAAA,GAGA5H,EAAAjB,UAAAyQ,WAAA,SAAAtL,EAAA0D,EAAAtE,EAAAoH,GAGA,GAFAxG,KACA0D,GAAA,GACA8C,EAAA,CACA,GAAA+E,GAAA5G,KAAAuF,IAAA,IAAA9K,EAAA,EAEA6G,GAAArM,KAAAoG,EAAA0D,EAAAtE,EAAAmM,EAAA,GAAAA,GAGA,GAAArN,GAAA,EACAyL,EAAA,EACA6B,EAAA,CAEA,KADA5R,KAAA8J,GAAA,IAAA1D,IACA9B,EAAAkB,IAAAuK,GAAA,MACA3J,EAAA,OAAAwL,GAAA,IAAA5R,KAAA8J,EAAAxF,EAAA,KACAsN,EAAA,GAEA5R,KAAA8J,EAAAxF,IAAA8B,EAAA2J,GAAA,GAAA6B,EAAA,GAGA,OAAA9H,GAAAtE,GAGAtD,EAAAjB,UAAA4Q,WAAA,SAAAzL,EAAA0D,EAAAtE,EAAAoH,GAGA,GAFAxG,KACA0D,GAAA,GACA8C,EAAA,CACA,GAAA+E,GAAA5G,KAAAuF,IAAA,IAAA9K,EAAA,EAEA6G,GAAArM,KAAAoG,EAAA0D,EAAAtE,EAAAmM,EAAA,GAAAA,GAGA,GAAArN,GAAAkB,EAAA,EACAuK,EAAA,EACA6B,EAAA,CAEA,KADA5R,KAAA8J,EAAAxF,GAAA,IAAA8B,IACA9B,GAAA,IAAAyL,GAAA,MACA3J,EAAA,OAAAwL,GAAA,IAAA5R,KAAA8J,EAAAxF,EAAA,KACAsN,EAAA,GAEA5R,KAAA8J,EAAAxF,IAAA8B,EAAA2J,GAAA,GAAA6B,EAAA,GAGA,OAAA9H,GAAAtE,GAGAtD,EAAAjB,UAAA6Q,UAAA,SAAA1L,EAAA0D,EAAA8C,GAOA,MANAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,YACA5H,EAAAyD,sBAAAS,EAAA2E,KAAAsG,MAAAjL,IACAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,GACApG,KAAA8J,GAAA,IAAA1D,EACA0D,EAAA,GAGA5H,EAAAjB,UAAA8Q,aAAA,SAAA3L,EAAA0D,EAAA8C,GAUA,MATAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,gBACA5H,EAAAyD,qBACA3F,KAAA8J,GAAA,IAAA1D,EACApG,KAAA8J,EAAA,GAAA1D,IAAA,GAEAmG,EAAAvM,KAAAoG,EAAA0D,GAAA,GAEAA,EAAA,GAGA5H,EAAAjB,UAAA+Q,aAAA,SAAA5L,EAAA0D,EAAA8C,GAUA,MATAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,gBACA5H,EAAAyD,qBACA3F,KAAA8J,GAAA1D,IAAA,EACApG,KAAA8J,EAAA,OAAA1D,GAEAmG,EAAAvM,KAAAoG,EAAA0D,GAAA,GAEAA,EAAA,GAGA5H,EAAAjB,UAAAgR,aAAA,SAAA7L,EAAA0D,EAAA8C,GAYA,MAXAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,0BACA5H,EAAAyD,qBACA3F,KAAA8J,GAAA,IAAA1D,EACApG,KAAA8J,EAAA,GAAA1D,IAAA,EACApG,KAAA8J,EAAA,GAAA1D,IAAA,GACApG,KAAA8J,EAAA,GAAA1D,IAAA,IAEAqG,EAAAzM,KAAAoG,EAAA0D,GAAA,GAEAA,EAAA,GAGA5H,EAAAjB,UAAAiR,aAAA,SAAA9L,EAAA0D,EAAA8C,GAaA,MAZAxG,MACA0D,GAAA,EACA8C,GAAAP,EAAArM,KAAAoG,EAAA0D,EAAA,0BACA1D,EAAA,IAAAA,EAAA,WAAAA,EAAA,GACAlE,EAAAyD,qBACA3F,KAAA8J,GAAA1D,IAAA,GACApG,KAAA8J,EAAA,GAAA1D,IAAA,GACApG,KAAA8J,EAAA,GAAA1D,IAAA,EACApG,KAAA8J,EAAA,OAAA1D,GAEAqG,EAAAzM,KAAAoG,EAAA0D,GAAA,GAEAA,EAAA,GAgBA5H,EAAAjB,UAAAkR,aAAA,SAAA/L,EAAA0D,EAAA8C,GACA,MAAAD,GAAA3M,KAAAoG,EAAA0D,GAAA,EAAA8C,IAGA1K,EAAAjB,UAAAmR,aAAA,SAAAhM,EAAA0D,EAAA8C,GACA,MAAAD,GAAA3M,KAAAoG,EAAA0D,GAAA,EAAA8C,IAWA1K,EAAAjB,UAAAoR,cAAA,SAAAjM,EAAA0D,EAAA8C,GACA,MAAAE,GAAA9M,KAAAoG,EAAA0D,GAAA,EAAA8C,IAGA1K,EAAAjB,UAAAqR,cAAA,SAAAlM,EAAA0D,EAAA8C,GACA,MAAAE,GAAA9M,KAAAoG,EAAA0D,GAAA,EAAA8C,IAIA1K,EAAAjB,UAAAwG,KAAA,SAAAyH,EAAAqD,EAAApK,EAAAC,GAQA,GAPAD,MAAA,GACAC,GAAA,IAAAA,MAAApI,KAAAwE,QACA+N,GAAArD,EAAA1K,SAAA+N,EAAArD,EAAA1K,QACA+N,MAAA,GACAnK,EAAA,GAAAA,EAAAD,IAAAC,EAAAD,GAGAC,IAAAD,EAAA,QACA,QAAA+G,EAAA1K,QAAA,IAAAxE,KAAAwE,OAAA,QAGA,IAAA+N,EAAA,EACA,SAAAzM,YAAA,4BAEA,IAAAqC,EAAA,GAAAA,GAAAnI,KAAAwE,OAAA,SAAAsB,YAAA,4BACA,IAAAsC,EAAA,WAAAtC,YAAA,0BAGAsC,GAAApI,KAAAwE,SAAA4D,EAAApI,KAAAwE,QACA0K,EAAA1K,OAAA+N,EAAAnK,EAAAD,IACAC,EAAA8G,EAAA1K,OAAA+N,EAAApK,EAGA,IACA7D,GADAkD,EAAAY,EAAAD,CAGA,IAAAnI,OAAAkP,GAAA/G,EAAAoK,KAAAnK,EAEA,IAAA9D,EAAAkD,EAAA,EAAqBlD,GAAA,IAAQA,EAC7B4K,EAAA5K,EAAAiO,GAAAvS,KAAAsE,EAAA6D,OAEG,IAAAX,EAAA,MAAAtF,EAAAyD,oBAEH,IAAArB,EAAA,EAAeA,EAAAkD,IAASlD,EACxB4K,EAAA5K,EAAAiO,GAAAvS,KAAAsE,EAAA6D,OAGA/C,YAAAnE,UAAAuR,IAAAjS,KACA2O,EACAlP,KAAAuF,SAAA4C,IAAAX,GACA+K,EAIA,OAAA/K,IAOAtF,EAAAjB,UAAA2F,KAAA,SAAAxE,EAAA+F,EAAAC,EAAAvB,GAEA,mBAAAzE,GAAA,CASA,GARA,gBAAA+F,IACAtB,EAAAsB,EACAA,EAAA,EACAC,EAAApI,KAAAwE,QACK,gBAAA4D,KACLvB,EAAAuB,EACAA,EAAApI,KAAAwE,QAEA,IAAApC,EAAAoC,OAAA,CACA,GAAAiO,GAAArQ,EAAAiL,WAAA,EACAoF,GAAA,MACArQ,EAAAqQ,GAGA,GAAA3L,SAAAD,GAAA,gBAAAA,GACA,SAAAR,WAAA,4BAEA,oBAAAQ,KAAA3E,EAAA+E,WAAAJ,GACA,SAAAR,WAAA,qBAAAQ,OAEG,gBAAAzE,KACHA,GAAA,IAIA,IAAA+F,EAAA,GAAAnI,KAAAwE,OAAA2D,GAAAnI,KAAAwE,OAAA4D,EACA,SAAAtC,YAAA,qBAGA,IAAAsC,GAAAD,EACA,MAAAnI,KAGAmI,MAAA,EACAC,EAAAtB,SAAAsB,EAAApI,KAAAwE,OAAA4D,IAAA,EAEAhG,MAAA,EAEA,IAAAkC,EACA,oBAAAlC,GACA,IAAAkC,EAAA6D,EAAmB7D,EAAA8D,IAAS9D,EAC5BtE,KAAAsE,GAAAlC,MAEG,CACH,GAAA8J,GAAAhK,EAAAI,SAAAF,GACAA,EACA2F,EAAA,GAAA7F,GAAAE,EAAAyE,GAAAxE,YACAmF,EAAA0E,EAAA1H,MACA,KAAAF,EAAA,EAAeA,EAAA8D,EAAAD,IAAiB7D,EAChCtE,KAAAsE,EAAA6D,GAAA+D,EAAA5H,EAAAkD,GAIA,MAAAxH,MAMA,IAAAiN,IAAA,uBLwkB8B1M,KAAKX,EAAU,WAAa,MAAOI,WAI3D,SAASH,EAAQD,GMzrEvB,YAmBA,SAAA8S,GAAAC,GACA,GAAAnL,GAAAmL,EAAAnO,MACA,IAAAgD,EAAA,IACA,SAAAvB,OAAA,iDAQA,aAAA0M,EAAAnL,EAAA,WAAAmL,EAAAnL,EAAA,OAGA,QAAAhC,GAAAmN,GAEA,SAAAA,EAAAnO,OAAA,EAAAkO,EAAAC,GAGA,QAAAlF,GAAAkF,GACA,GAAArO,GAAAsF,EAAArF,EAAAqO,EAAAC,EAAA1N,EACAqC,EAAAmL,EAAAnO,MACAqO,GAAAH,EAAAC,GAEAxN,EAAA,GAAA2N,GAAA,EAAAtL,EAAA,EAAAqL,GAGAtO,EAAAsO,EAAA,EAAArL,EAAA,EAAAA,CAEA,IAAAuL,GAAA,CAEA,KAAAzO,EAAA,EAAAsF,EAAA,EAAoBtF,EAAAC,EAAOD,GAAA,EAAAsF,GAAA,EAC3BgJ,EAAAI,EAAAL,EAAAtF,WAAA/I,KAAA,GAAA0O,EAAAL,EAAAtF,WAAA/I,EAAA,QAAA0O,EAAAL,EAAAtF,WAAA/I,EAAA,OAAA0O,EAAAL,EAAAtF,WAAA/I,EAAA,IACAa,EAAA4N,KAAAH,GAAA,OACAzN,EAAA4N,KAAAH,GAAA,MACAzN,EAAA4N,KAAA,IAAAH,CAYA,OATA,KAAAC,GACAD,EAAAI,EAAAL,EAAAtF,WAAA/I,KAAA,EAAA0O,EAAAL,EAAAtF,WAAA/I,EAAA,OACAa,EAAA4N,KAAA,IAAAH,GACG,IAAAC,IACHD,EAAAI,EAAAL,EAAAtF,WAAA/I,KAAA,GAAA0O,EAAAL,EAAAtF,WAAA/I,EAAA,OAAA0O,EAAAL,EAAAtF,WAAA/I,EAAA,OACAa,EAAA4N,KAAAH,GAAA,MACAzN,EAAA4N,KAAA,IAAAH,GAGAzN,EAGA,QAAA8N,GAAAC,GACA,MAAAC,GAAAD,GAAA,OAAAC,EAAAD,GAAA,OAAAC,EAAAD,GAAA,MAAAC,EAAA,GAAAD,GAGA,QAAAE,GAAAC,EAAAlL,EAAAC,GAGA,OAFAwK,GACAU,KACAhP,EAAA6D,EAAqB7D,EAAA8D,EAAS9D,GAAA,EAC9BsO,GAAAS,EAAA/O,IAAA,KAAA+O,EAAA/O,EAAA,OAAA+O,EAAA/O,EAAA,GACAgP,EAAA7H,KAAAwH,EAAAL,GAEA,OAAAU,GAAArE,KAAA,IAGA,QAAAnE,GAAAuI,GASA,OARAT,GACApL,EAAA6L,EAAA7O,OACA+O,EAAA/L,EAAA,EACA8L,EAAA,GACAE,KACAC,EAAA,MAGAnP,EAAA,EAAAoP,EAAAlM,EAAA+L,EAA0CjP,EAAAoP,EAAUpP,GAAAmP,EACpDD,EAAA/H,KAAA2H,EAAAC,EAAA/O,IAAAmP,EAAAC,IAAApP,EAAAmP,GAmBA,OAfA,KAAAF,GACAX,EAAAS,EAAA7L,EAAA,GACA8L,GAAAH,EAAAP,GAAA,GACAU,GAAAH,EAAAP,GAAA,MACAU,GAAA,MACG,IAAAC,IACHX,GAAAS,EAAA7L,EAAA,OAAA6L,EAAA7L,EAAA,GACA8L,GAAAH,EAAAP,GAAA,IACAU,GAAAH,EAAAP,GAAA,MACAU,GAAAH,EAAAP,GAAA,MACAU,GAAA,KAGAE,EAAA/H,KAAA6H,GAEAE,EAAAvE,KAAA,IA9GArP,EAAA4F,aACA5F,EAAA6N,cACA7N,EAAAkL,eAOA,QALAqI,MACAH,KACAF,EAAA,mBAAA1N,uBAAAsK,MAEA+C,EAAA,mEACAnO,EAAA,EAAAkD,EAAAiL,EAAAjO,OAAkCF,EAAAkD,IAASlD,EAC3C6O,EAAA7O,GAAAmO,EAAAnO,GACA0O,EAAAP,EAAApF,WAAA/I,KAGA0O,GAAA,IAAA3F,WAAA,OACA2F,EAAA,IAAA3F,WAAA,QNgyEM,SAASxN,EAAQD,GOjzEvBA,EAAAuJ,KAAA,SAAArG,EAAAgH,EAAA6J,EAAAC,EAAAC,GACA,GAAApO,GAAAjF,EACAsT,EAAA,EAAAD,EAAAD,EAAA,EACAG,GAAA,GAAAD,GAAA,EACAE,EAAAD,GAAA,EACAE,GAAA,EACA3P,EAAAqP,EAAAE,EAAA,IACAK,EAAAP,GAAA,IACAQ,EAAArR,EAAAgH,EAAAxF,EAOA,KALAA,GAAA4P,EAEAzO,EAAA0O,GAAA,IAAAF,GAAA,EACAE,KAAAF,EACAA,GAAAH,EACQG,EAAA,EAAWxO,EAAA,IAAAA,EAAA3C,EAAAgH,EAAAxF,MAAA4P,EAAAD,GAAA,GAKnB,IAHAzT,EAAAiF,GAAA,IAAAwO,GAAA,EACAxO,KAAAwO,EACAA,GAAAL,EACQK,EAAA,EAAWzT,EAAA,IAAAA,EAAAsC,EAAAgH,EAAAxF,MAAA4P,EAAAD,GAAA,GAEnB,OAAAxO,EACAA,EAAA,EAAAuO,MACG,IAAAvO,IAAAsO,EACH,MAAAvT,GAAA4T,KAAAD,GAAA,MAAAhH,IAEA3M,IAAAuK,KAAAuF,IAAA,EAAAsD,GACAnO,GAAAuO,EAEA,OAAAG,GAAA,KAAA3T,EAAAuK,KAAAuF,IAAA,EAAA7K,EAAAmO,IAGAhU,EAAAuH,MAAA,SAAArE,EAAAsD,EAAA0D,EAAA6J,EAAAC,EAAAC,GACA,GAAApO,GAAAjF,EAAAC,EACAqT,EAAA,EAAAD,EAAAD,EAAA,EACAG,GAAA,GAAAD,GAAA,EACAE,EAAAD,GAAA,EACAM,EAAA,KAAAT,EAAA7I,KAAAuF,IAAA,OAAAvF,KAAAuF,IAAA,SACAhM,EAAAqP,EAAA,EAAAE,EAAA,EACAK,EAAAP,EAAA,KACAQ,EAAA/N,EAAA,OAAAA,GAAA,EAAAA,EAAA,KAmCA,KAjCAA,EAAA2E,KAAAuJ,IAAAlO,GAEA2C,MAAA3C,QAAA+G,KACA3M,EAAAuI,MAAA3C,GAAA,IACAX,EAAAsO,IAEAtO,EAAAsF,KAAAsG,MAAAtG,KAAAwJ,IAAAnO,GAAA2E,KAAAyJ,KACApO,GAAA3F,EAAAsK,KAAAuF,IAAA,GAAA7K,IAAA,IACAA,IACAhF,GAAA,GAGA2F,GADAX,EAAAuO,GAAA,EACAK,EAAA5T,EAEA4T,EAAAtJ,KAAAuF,IAAA,IAAA0D,GAEA5N,EAAA3F,GAAA,IACAgF,IACAhF,GAAA,GAGAgF,EAAAuO,GAAAD,GACAvT,EAAA,EACAiF,EAAAsO,GACKtO,EAAAuO,GAAA,GACLxT,GAAA4F,EAAA3F,EAAA,GAAAsK,KAAAuF,IAAA,EAAAsD,GACAnO,GAAAuO,IAEAxT,EAAA4F,EAAA2E,KAAAuF,IAAA,EAAA0D,EAAA,GAAAjJ,KAAAuF,IAAA,EAAAsD,GACAnO,EAAA,IAIQmO,GAAA,EAAW9Q,EAAAgH,EAAAxF,GAAA,IAAA9D,EAAA8D,GAAA4P,EAAA1T,GAAA,IAAAoT,GAAA,GAInB,IAFAnO,KAAAmO,EAAApT,EACAsT,GAAAF,EACQE,EAAA,EAAUhR,EAAAgH,EAAAxF,GAAA,IAAAmB,EAAAnB,GAAA4P,EAAAzO,GAAA,IAAAqO,GAAA,GAElBhR,EAAAgH,EAAAxF,EAAA4P,IAAA,IAAAC,IPyzEM,SAAStU,EAAQD,GQ34EvB,GAAAyC,MAAiBA,QAEjBxC,GAAAD,QAAA8P,MAAAvN,SAAA,SAAAgD,GACA,wBAAA9C,EAAA9B,KAAA4E,KRm5EM,SAAStF,EAAQD,GSt5EvB,YAEAC,GAAAD,QAAA,SAAAyE,EAAAW,GACA,kBAEA,OADAyP,GAAA,GAAA/E,OAAA7K,UAAAL,QACAF,EAAA,EAAmBA,EAAAmQ,EAAAjQ,OAAiBF,IACpCmQ,EAAAnQ,GAAAO,UAAAP,EAEA,OAAAD,GAAAyH,MAAA9G,EAAAyP,MT+5EM,SAAS5U,EAAQD,EAASM,GUv6EhC,YAcA,SAAAY,GAAAU,GACAxB,KAAAqB,SAAAG,EACAxB,KAAA0U,cACAxT,QAAA,GAAAyT,GACAC,SAAA,GAAAD,IAhBA,GAAAtT,GAAAnB,EAAA,GACAiB,EAAAjB,EAAA,GACAyU,EAAAzU,EAAA,IACA2U,EAAA3U,EAAA,IACA4U,EAAA5U,EAAA,IACA6U,EAAA7U,EAAA,GAoBAY,GAAAG,UAAAC,QAAA,SAAA8T,GAGA,gBAAAA,KACAA,EAAA7T,EAAAM,OACAwT,IAAApQ,UAAA,IACKA,UAAA,KAGLmQ,EAAA7T,EAAAM,MAAAJ,EAAArB,KAAAqB,UAAiD6T,OAAA,OAAgBF,GAGjEA,EAAAG,UAAAL,EAAAE,EAAAC,OACAD,EAAAC,IAAAF,EAAAC,EAAAG,QAAAH,EAAAC,KAIA,IAAAG,IAAAP,EAAA/N,QACAuO,EAAAtT,QAAAuT,QAAAN,EAUA,KARAhV,KAAA0U,aAAAxT,QAAAiD,QAAA,SAAAoR,GACAH,EAAAI,QAAAD,EAAAE,UAAAF,EAAAG,YAGA1V,KAAA0U,aAAAE,SAAAzQ,QAAA,SAAAoR,GACAH,EAAA3J,KAAA8J,EAAAE,UAAAF,EAAAG,YAGAN,EAAA5Q,QACA6Q,IAAAM,KAAAP,EAAAQ,QAAAR,EAAAQ,QAGA,OAAAP,IAIAlU,EAAAgD,SAAA,0CAAA+Q,GAEApU,EAAAG,UAAAiU,GAAA,SAAAD,EAAAD,GACA,MAAAhV,MAAAkB,QAAAC,EAAAM,MAAAuT,OACAE,SACAD,YAKA9T,EAAAgD,SAAA,+BAAA+Q,GAEApU,EAAAG,UAAAiU,GAAA,SAAAD,EAAArN,EAAAoN,GACA,MAAAhV,MAAAkB,QAAAC,EAAAM,MAAAuT,OACAE,SACAD,MACArN,aAKA/H,EAAAD,QAAAkB,GV86EM,SAASjB,EAAQD,EAASM,GWlgFhC,YASA,SAAA2V,GAAAC,EAAA1P,IACAjF,EAAA8B,YAAA6S,IAAA3U,EAAA8B,YAAA6S,EAAA,mBACAA,EAAA,gBAAA1P,GAIA,QAAA2P,KACA,GAAAC,EAQA,OAPA,mBAAAC,gBAEAD,EAAA9V,EAAA,IACG,mBAAAgW,WAEHF,EAAA9V,EAAA,KAEA8V,EAtBA,GAAA7U,GAAAjB,EAAA,GACAiW,EAAAjW,EAAA,IAEAkW,GACAC,eAAA,qCAqBAhV,GACA2U,QAAAD,IAEAO,kBAAA,SAAA1O,EAAAkO,GAEA,MADAK,GAAAL,EAAA,gBACA3U,EAAAqB,WAAAoF,IACAzG,EAAAoB,cAAAqF,IACAzG,EAAAmB,SAAAsF,IACAzG,EAAAoC,SAAAqE,IACAzG,EAAAiC,OAAAwE,IACAzG,EAAAkC,OAAAuE,GAEAA,EAEAzG,EAAAuB,kBAAAkF,GACAA,EAAA9E,OAEA3B,EAAAsC,kBAAAmE,IACAiO,EAAAC,EAAA,mDACAlO,EAAAvF,YAEAlB,EAAA+B,SAAA0E,IACAiO,EAAAC,EAAA,kCACAS,KAAAC,UAAA5O,IAEAA,IAGA6O,mBAAA,SAAA7O,GAEA,mBAAAA,GACA,IACAA,EAAA2O,KAAAG,MAAA9O,GACO,MAAAnC,IAEP,MAAAmC,KAGA+O,QAAA,EAEAC,eAAA,aACAC,eAAA,eAEAC,kBAAA,EAEAC,eAAA,SAAAC,GACA,MAAAA,IAAA,KAAAA,EAAA,KAIA3V,GAAAyU,SACAmB,QACAC,OAAA,sCAIA/V,EAAAgD,SAAA,gCAAA+Q,GACA7T,EAAAyU,QAAAZ,QAGA/T,EAAAgD,SAAA,+BAAA+Q,GACA7T,EAAAyU,QAAAZ,GAAA/T,EAAAM,MAAA2U,KAGAvW,EAAAD,QAAAyB,GXygFM,SAASxB,EAAQD,EAASM,GYpmFhC,YAEA,IAAAiB,GAAAjB,EAAA,EAEAL,GAAAD,QAAA,SAAAkW,EAAAqB,GACAhW,EAAAgD,QAAA2R,EAAA,SAAA1P,EAAAgR,GACAA,IAAAD,GAAAC,EAAAC,gBAAAF,EAAAE,gBACAvB,EAAAqB,GAAA/Q,QACA0P,GAAAsB,QZ8mFM,SAASvX,EAAQD,EAASM,GatnFhC,YAEA,IAAAiB,GAAAjB,EAAA,GACAoX,EAAApX,EAAA,IACAqX,EAAArX,EAAA,IACAsX,EAAAtX,EAAA,IACAuX,EAAAvX,EAAA,IACAwX,EAAAxX,EAAA,IACAyX,EAAA,mBAAA1T,gBAAA0T,MAAA1T,OAAA0T,KAAA3W,KAAAiD,SAAA/D,EAAA,GAEAL,GAAAD,QAAA,SAAAoV,GACA,UAAAjT,SAAA,SAAAuT,EAAAsC,GACA,GAAAC,GAAA7C,EAAApN,KACAkQ,EAAA9C,EAAAc,OAEA3U,GAAAqB,WAAAqV,UACAC,GAAA,eAGA,IAAA5W,GAAA,GAAA+U,gBACA8B,EAAA,qBACAC,GAAA,CAiBA,IAXA,mBAAA/T,UACAA,OAAAgU,gBAAA,mBAAA/W,IACAuW,EAAAzC,EAAAC,OACA/T,EAAA,GAAA+C,QAAAgU,eACAF,EAAA,SACAC,GAAA,EACA9W,EAAAgX,WAAA,aACAhX,EAAAiX,UAAA,cAIAnD,EAAAoD,KAAA,CACA,GAAAC,GAAArD,EAAAoD,KAAAC,UAAA,GACAC,EAAAtD,EAAAoD,KAAAE,UAAA,EACAR,GAAAS,cAAA,SAAAZ,EAAAU,EAAA,IAAAC,GA8DA,GA3DApX,EAAAsX,KAAAxD,EAAAE,OAAAmC,cAAAE,EAAAvC,EAAAC,IAAAD,EAAAyD,OAAAzD,EAAA0D,mBAAA,GAGAxX,EAAAyV,QAAA3B,EAAA2B,QAGAzV,EAAA6W,GAAA,WACA,GAAA7W,IAAA,IAAAA,EAAAyX,YAAAX,KAQA,IAAA9W,EAAA8V,QAAA9V,EAAA0X,aAAA,IAAA1X,EAAA0X,YAAA3P,QAAA,WAKA,GAAA4P,GAAA,yBAAA3X,GAAAsW,EAAAtW,EAAA4X,yBAAA,KACAC,EAAA/D,EAAAgE,cAAA,SAAAhE,EAAAgE,aAAA9X,EAAA0T,SAAA1T,EAAA+X,aACArE,GACAhN,KAAAmR,EAEA/B,OAAA,OAAA9V,EAAA8V,OAAA,IAAA9V,EAAA8V,OACAkC,WAAA,OAAAhY,EAAA8V,OAAA,aAAA9V,EAAAgY,WACApD,QAAA+C,EACA7D,SACA9T,UAGAoW,GAAAhC,EAAAsC,EAAAhD,GAGA1T,EAAA,OAIAA,EAAAiY,QAAA,WAGAvB,EAAAF,EAAA,gBAAA1C,IAGA9T,EAAA,MAIAA,EAAAiX,UAAA,WACAP,EAAAF,EAAA,cAAA1C,EAAA2B,QAAA,cAAA3B,EAAA,iBAGA9T,EAAA,MAMAC,EAAA2C,uBAAA,CACA,GAAAsV,GAAAlZ,EAAA,IAGAmZ,GAAArE,EAAAsE,iBAAA7B,EAAAzC,EAAAC,OAAAD,EAAA4B,eACAwC,EAAAjQ,KAAA6L,EAAA4B,gBACA9P,MAEAuS,KACAvB,EAAA9C,EAAA6B,gBAAAwC,GAuBA,GAlBA,oBAAAnY,IACAC,EAAAgD,QAAA2T,EAAA,SAAA1V,EAAAqC,GACA,mBAAAoT,IAAA,iBAAApT,EAAAwD,oBAEA6P,GAAArT,GAGAvD,EAAAqY,iBAAA9U,EAAArC,KAMA4S,EAAAsE,kBACApY,EAAAoY,iBAAA,GAIAtE,EAAAgE,aACA,IACA9X,EAAA8X,aAAAhE,EAAAgE,aACO,MAAAvT,GAGP,YAAAuP,EAAAgE,aACA,KAAAvT,GAMA,kBAAAuP,GAAAwE,oBACAtY,EAAAuY,iBAAA,WAAAzE,EAAAwE,oBAIA,kBAAAxE,GAAA0E,kBAAAxY,EAAAyY,QACAzY,EAAAyY,OAAAF,iBAAA,WAAAzE,EAAA0E,kBAGA1E,EAAA4E,aAEA5E,EAAA4E,YAAAvE,QAAAM,KAAA,SAAAkE,GACA3Y,IAIAA,EAAA4Y,QACAlC,EAAAiC,GAEA3Y,EAAA,QAIA4F,SAAA+Q,IACAA,EAAA,MAIA3W,EAAA6Y,KAAAlC,Ob+nFM,SAAShY,EAAQD,EAASM,Gc/yFhC,YAEA,IAAAwX,GAAAxX,EAAA,GASAL,GAAAD,QAAA,SAAA0V,EAAAsC,EAAAhD,GACA,GAAAmC,GAAAnC,EAAAI,OAAA+B,cAEAnC,GAAAoC,QAAAD,MAAAnC,EAAAoC,QAGAY,EAAAF,EACA,mCAAA9C,EAAAoC,OACApC,EAAAI,OACA,KACAJ,IANAU,EAAAV,Kd+zFM,SAAS/U,EAAQD,EAASM,Ge90FhC,YAEA,IAAA8Z,GAAA9Z,EAAA,GAWAL,GAAAD,QAAA,SAAAqa,EAAAjF,EAAAvC,EAAAmC,GACA,GAAAsF,GAAA,GAAAjU,OAAAgU,EACA,OAAAD,GAAAE,EAAAlF,EAAAvC,EAAAmC,Kfs1FM,SAAS/U,EAAQD,GgBr2FvB,YAWAC,GAAAD,QAAA,SAAAsa,EAAAlF,EAAAvC,EAAAmC,GAMA,MALAsF,GAAAlF,SACAvC,IACAyH,EAAAzH,QAEAyH,EAAAtF,WACAsF,IhB62FM,SAASra,EAAQD,EAASM,GiB93FhC,YAIA,SAAAia,GAAA/X,GACA,MAAAgY,oBAAAhY,GACAyB,QAAA,aACAA,QAAA,aACAA,QAAA,YACAA,QAAA,aACAA,QAAA,YACAA,QAAA,aACAA,QAAA,aAVA,GAAA1C,GAAAjB,EAAA,EAoBAL,GAAAD,QAAA,SAAAqV,EAAAwD,EAAAC,GAEA,IAAAD,EACA,MAAAxD,EAGA,IAAAoF,EACA,IAAA3B,EACA2B,EAAA3B,EAAAD,OACG,IAAAtX,EAAAsC,kBAAAgV,GACH4B,EAAA5B,EAAApW,eACG,CACH,GAAAmR,KAEArS,GAAAgD,QAAAsU,EAAA,SAAArW,EAAAqC,GACA,OAAArC,GAAA,mBAAAA,KAIAjB,EAAAgB,QAAAC,KACAqC,GAAA,MAGAtD,EAAAgB,QAAAC,KACAA,OAGAjB,EAAAgD,QAAA/B,EAAA,SAAAkY,GACAnZ,EAAAgC,OAAAmX,GACAA,IAAAC,cACSpZ,EAAA+B,SAAAoX,KACTA,EAAA/D,KAAAC,UAAA8D,IAEA9G,EAAA/H,KAAA0O,EAAA1V,GAAA,IAAA0V,EAAAG,SAIAD,EAAA7G,EAAAvE,KAAA,KAOA,MAJAoL,KACApF,MAAAhM,QAAA,mBAAAoR,GAGApF,IjBs4FM,SAASpV,EAAQD,EAASM,GkBx8FhC,YAEA,IAAAiB,GAAAjB,EAAA,EAeAL,GAAAD,QAAA,SAAAkW,GACA,GACArR,GACArC,EACAkC,EAHA4F,IAKA,OAAA4L,IAEA3U,EAAAgD,QAAA2R,EAAA0E,MAAA,eAAAC,GACAnW,EAAAmW,EAAAxR,QAAA,KACAxE,EAAAtD,EAAAwC,KAAA8W,EAAArQ,OAAA,EAAA9F,IAAA2D,cACA7F,EAAAjB,EAAAwC,KAAA8W,EAAArQ,OAAA9F,EAAA,IAEAG,IACAyF,EAAAzF,GAAAyF,EAAAzF,GAAAyF,EAAAzF,GAAA,KAAArC,OAIA8H,GAZiBA,IlB49FX,SAASrK,EAAQD,EAASM,GmBn/FhC,YAEA,IAAAiB,GAAAjB,EAAA,EAEAL,GAAAD,QACAuB,EAAA2C,uBAIA,WAWA,QAAA4W,GAAAzF,GACA,GAAA0F,GAAA1F,CAWA,OATA2F,KAEAC,EAAAC,aAAA,OAAAH,GACAA,EAAAE,EAAAF,MAGAE,EAAAC,aAAA,OAAAH,IAIAA,KAAAE,EAAAF,KACAI,SAAAF,EAAAE,SAAAF,EAAAE,SAAAlX,QAAA,YACAmX,KAAAH,EAAAG,KACAC,OAAAJ,EAAAI,OAAAJ,EAAAI,OAAApX,QAAA,aACAqX,KAAAL,EAAAK,KAAAL,EAAAK,KAAArX,QAAA,YACAsX,SAAAN,EAAAM,SACAC,KAAAP,EAAAO,KACAC,SAAA,MAAAR,EAAAQ,SAAAC,OAAA,GACAT,EAAAQ,SACA,IAAAR,EAAAQ,UAhCA,GAEAE,GAFAX,EAAA,kBAAAY,KAAAzX,UAAA0X,WACAZ,EAAA3W,SAAAwX,cAAA,IA2CA,OARAH,GAAAb,EAAAzW,OAAA0X,SAAAhB,MAQA,SAAAiB,GACA,GAAA1R,GAAA/I,EAAA4B,SAAA6Y,GAAAlB,EAAAkB,IACA,OAAA1R,GAAA6Q,WAAAQ,EAAAR,UACA7Q,EAAA8Q,OAAAO,EAAAP,SAKA,WACA,kBACA,cnB6/FM,SAASnb,EAAQD,GoB7jGvB,YAMA,SAAAic,KACA7b,KAAAia,QAAA,uCAMA,QAAAtC,GAAAmE,GAGA,IAEA,GAAAC,GAAAC,EAJApY,EAAA6F,OAAAqS,GACAxI,EAAA,GAGA2I,EAAA,EAAAC,EAAAC,EAIAvY,EAAA0X,OAAA,EAAAW,KAAAC,EAAA,IAAAD,EAAA,GAEA3I,GAAA4I,EAAAZ,OAAA,GAAAS,GAAA,EAAAE,EAAA,KACA,CAEA,GADAD,EAAApY,EAAAyJ,WAAA4O,GAAA,KACAD,EAAA,IACA,SAAAH,EAEAE,MAAA,EAAAC,EAEA,MAAA1I,GA5BA,GAAA6I,GAAA,mEAKAN,GAAA5a,UAAA,GAAAgF,OACA4V,EAAA5a,UAAAwR,KAAA,EACAoJ,EAAA5a,UAAAmW,KAAA,wBAwBAvX,EAAAD,QAAA+X,GpBokGM,SAAS9X,EAAQD,EAASM,GqBvmGhC,YAEA,IAAAiB,GAAAjB,EAAA,EAEAL,GAAAD,QACAuB,EAAA2C,uBAGA,WACA,OACAqD,MAAA,SAAAiQ,EAAAhR,EAAAgW,EAAAC,EAAAC,EAAAC,GACA,GAAAC,KACAA,GAAA/Q,KAAA2L,EAAA,IAAAgD,mBAAAhU,IAEAjF,EAAA6B,SAAAoZ,IACAI,EAAA/Q,KAAA,cAAAgR,MAAAL,GAAAM,eAGAvb,EAAA4B,SAAAsZ,IACAG,EAAA/Q,KAAA,QAAA4Q,GAGAlb,EAAA4B,SAAAuZ,IACAE,EAAA/Q,KAAA,UAAA6Q,GAGAC,KAAA,GACAC,EAAA/Q,KAAA,UAGAvH,SAAAsY,SAAAvN,KAAA,OAGA9F,KAAA,SAAAiO,GACA,GAAApI,GAAA9K,SAAAsY,OAAAxN,MAAA,GAAA2N,QAAA,aAA0DvF,EAAA,aAC1D,OAAApI,GAAA4N,mBAAA5N,EAAA,UAGA6N,OAAA,SAAAzF,GACApX,KAAAmH,MAAAiQ,EAAA,GAAAqF,KAAAK,MAAA,YAMA,WACA,OACA3V,MAAA,aACAgC,KAAA,WAA6B,aAC7B0T,OAAA,kBrBinGM,SAAShd,EAAQD,EAASM,GsBlqGhC,YAIA,SAAAyU,KACA3U,KAAA+c,YAHA,GAAA5b,GAAAjB,EAAA,EAcAyU,GAAA1T,UAAA+b,IAAA,SAAAvH,EAAAC,GAKA,MAJA1V,MAAA+c,SAAAtR,MACAgK,YACAC,aAEA1V,KAAA+c,SAAAvY,OAAA,GAQAmQ,EAAA1T,UAAAgc,MAAA,SAAA5c,GACAL,KAAA+c,SAAA1c,KACAL,KAAA+c,SAAA1c,GAAA,OAYAsU,EAAA1T,UAAAkD,QAAA,SAAAE,GACAlD,EAAAgD,QAAAnE,KAAA+c,SAAA,SAAAG,GACA,OAAAA,GACA7Y,EAAA6Y,MAKArd,EAAAD,QAAA+U,GtByqGM,SAAS9U,EAAQD,EAASM,GuB5tGhC,YAUA,SAAAid,GAAAnI,GACAA,EAAA4E,aACA5E,EAAA4E,YAAAwD,mBAVA,GAAAjc,GAAAjB,EAAA,GACAmd,EAAAnd,EAAA,IACA0B,EAAA1B,EAAA,IACAmB,EAAAnB,EAAA,EAiBAL,GAAAD,QAAA,SAAAoV,GACAmI,EAAAnI,GAGAA,EAAAc,QAAAd,EAAAc,YAGAd,EAAApN,KAAAyV,EACArI,EAAApN,KACAoN,EAAAc,QACAd,EAAAsB,kBAIAtB,EAAAc,QAAA3U,EAAAM,MACAuT,EAAAc,QAAAmB,WACAjC,EAAAc,QAAAd,EAAAE,YACAF,EAAAc,aAGA3U,EAAAgD,SACA,qDACA,SAAA+Q,SACAF,GAAAc,QAAAZ,IAIA,IAAAc,GAAAhB,EAAAgB,SAAA3U,EAAA2U,OAEA,OAAAA,GAAAhB,GAAAW,KAAA,SAAAf,GAUA,MATAuI,GAAAnI,GAGAJ,EAAAhN,KAAAyV,EACAzI,EAAAhN,KACAgN,EAAAkB,QACAd,EAAAyB,mBAGA7B,GACG,SAAA0I,GAcH,MAbA1b,GAAA0b,KACAH,EAAAnI,GAGAsI,KAAA1I,WACA0I,EAAA1I,SAAAhN,KAAAyV,EACAC,EAAA1I,SAAAhN,KACA0V,EAAA1I,SAAAkB,QACAd,EAAAyB,qBAKA1U,QAAA6V,OAAA0F,OvBquGM,SAASzd,EAAQD,EAASM,GwBjzGhC,YAEA,IAAAiB,GAAAjB,EAAA,EAUAL,GAAAD,QAAA,SAAAgI,EAAAkO,EAAAyH,GAMA,MAJApc,GAAAgD,QAAAoZ,EAAA,SAAAlZ,GACAuD,EAAAvD,EAAAuD,EAAAkO,KAGAlO,IxByzGM,SAAS/H,EAAQD,GyB30GvB,YAEAC,GAAAD,QAAA,SAAAwG,GACA,SAAAA,MAAAoX,czBm1GM,SAAS3d,EAAQD,G0Bt1GvB,YAQAC,GAAAD,QAAA,SAAAqV,GAIA,sCAAAuG,KAAAvG,K1B81GM,SAASpV,EAAQD,G2B12GvB,YASAC,GAAAD,QAAA,SAAAuV,EAAAsI,GACA,MAAAA,GACAtI,EAAAtR,QAAA,eAAA4Z,EAAA5Z,QAAA,WACAsR,I3Bk3GM,SAAStV,EAAQD,G4B93GvB,YAQA,SAAA8B,GAAAuY,GACAja,KAAAia,UAGAvY,EAAAT,UAAAoB,SAAA,WACA,gBAAArC,KAAAia,QAAA,KAAAja,KAAAia,QAAA,KAGAvY,EAAAT,UAAAuc,YAAA,EAEA3d,EAAAD,QAAA8B,G5Bq4GM,SAAS7B,EAAQD,EAASM,G6Bv5GhC,YAUA,SAAAyB,GAAA+b,GACA,qBAAAA,GACA,SAAArX,WAAA,+BAGA,IAAAsX,EACA3d,MAAAqV,QAAA,GAAAtT,SAAA,SAAAuT,GACAqI,EAAArI,GAGA,IAAAsI,GAAA5d,IACA0d,GAAA,SAAAzD,GACA2D,EAAAN,SAKAM,EAAAN,OAAA,GAAA5b,GAAAuY,GACA0D,EAAAC,EAAAN,WA1BA,GAAA5b,GAAAxB,EAAA,GAiCAyB,GAAAV,UAAAmc,iBAAA,WACA,GAAApd,KAAAsd,OACA,KAAAtd,MAAAsd,QAQA3b,EAAAkc,OAAA,WACA,GAAAhE,GACA+D,EAAA,GAAAjc,GAAA,SAAAlB,GACAoZ,EAAApZ,GAEA,QACAmd,QACA/D,WAIAha,EAAAD,QAAA+B,G7B85GM,SAAS9B,EAAQD,G8Bt9GvB,YAsBAC,GAAAD,QAAA,SAAAke,GACA,gBAAA3Y,GACA,MAAA2Y,GAAAhS,MAAA,KAAA3G",
file: "axios.min.js",
sourcesContent: [
"(function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define([], factory); else if(typeof exports === 'object') exports["axios"] = factory(); else root["axios"] = factory(); })(this, function() { return // WEBPACK FOOTER // // webpack/universalModuleDefinition",
"(function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define([], factory); else if(typeof exports === 'object') exports["axios"] = factory(); else root["axios"] = factory(); })(this, function() { return /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = ""; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { module.exports = __webpack_require__(1); /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); var bind = __webpack_require__(7); var Axios = __webpack_require__(8); var defaults = __webpack_require__(9); /** * Create an instance of Axios * * @param {Object} defaultConfig The default config for the instance * @return {Axios} A new instance of Axios */ function createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance utils.extend(instance, Axios.prototype, context); // Copy context to instance utils.extend(instance, context); return instance; } // Create the default instance to be exported var axios = createInstance(defaults); // Expose Axios class to allow class inheritance axios.Axios = Axios; // Factory for creating new instances axios.create = function create(instanceConfig) { return createInstance(utils.merge(defaults, instanceConfig)); }; // Expose Cancel & CancelToken axios.Cancel = __webpack_require__(26); axios.CancelToken = __webpack_require__(27); axios.isCancel = __webpack_require__(23); // Expose all/spread axios.all = function all(promises) { return Promise.all(promises); }; axios.spread = __webpack_require__(28); module.exports = axios; // Allow use of default import syntax in TypeScript module.exports.default = axios; /***/ }, /* 2 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(Buffer) {'use strict'; var bind = __webpack_require__(7); /*global toString:true*/ // utils is a library of generic helper functions non-specific to axios var toString = Object.prototype.toString; /** * Determine if a value is an Array * * @param {Object} val The value to test * @returns {boolean} True if value is an Array, otherwise false */ function isArray(val) { return toString.call(val) === '[object Array]'; } /** * Determine if a value is a Node Buffer * * @param {Object} val The value to test * @returns {boolean} True if value is a Node Buffer, otherwise false */ function isBuffer(val) { return ((typeof Buffer !== 'undefined') && (Buffer.isBuffer) && (Buffer.isBuffer(val))); } /** * Determine if a value is an ArrayBuffer * * @param {Object} val The value to test * @returns {boolean} True if value is an ArrayBuffer, otherwise false */ function isArrayBuffer(val) { return toString.call(val) === '[object ArrayBuffer]'; } /** * Determine if a value is a FormData * * @param {Object} val The value to test * @returns {boolean} True if value is an FormData, otherwise false */ function isFormData(val) { return (typeof FormData !== 'undefined') && (val instanceof FormData); } /** * Determine if a value is a view on an ArrayBuffer * * @param {Object} val The value to test * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false */ function isArrayBufferView(val) { var result; if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) { result = ArrayBuffer.isView(val); } else { result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer); } return result; } /** * Determine if a value is a String * * @param {Object} val The value to test * @returns {boolean} True if value is a String, otherwise false */ function isString(val) { return typeof val === 'string'; } /** * Determine if a value is a Number * * @param {Object} val The value to test * @returns {boolean} True if value is a Number, otherwise false */ function isNumber(val) { return typeof val === 'number'; } /** * Determine if a value is undefined * * @param {Object} val The value to test * @returns {boolean} True if the value is undefined, otherwise false */ function isUndefined(val) { return typeof val === 'undefined'; } /** * Determine if a value is an Object * * @param {Object} val The value to test * @returns {boolean} True if value is an Object, otherwise false */ function isObject(val) { return val !== null && typeof val === 'object'; } /** * Determine if a value is a Date * * @param {Object} val The value to test * @returns {boolean} True if value is a Date, otherwise false */ function isDate(val) { return toString.call(val) === '[object Date]'; } /** * Determine if a value is a File * * @param {Object} val The value to test * @returns {boolean} True if value is a File, otherwise false */ function isFile(val) { return toString.call(val) === '[object File]'; } /** * Determine if a value is a Blob * * @param {Object} val The value to test * @returns {boolean} True if value is a Blob, otherwise false */ function isBlob(val) { return toString.call(val) === '[object Blob]'; } /** * Determine if a value is a Function * * @param {Object} val The value to test * @returns {boolean} True if value is a Function, otherwise false */ function isFunction(val) { return toString.call(val) === '[object Function]'; } /** * Determine if a value is a Stream * * @param {Object} val The value to test * @returns {boolean} True if value is a Stream, otherwise false */ function isStream(val) { return isObject(val) && isFunction(val.pipe); } /** * Determine if a value is a URLSearchParams object * * @param {Object} val The value to test * @returns {boolean} True if value is a URLSearchParams object, otherwise false */ function isURLSearchParams(val) { return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams; } /** * Trim excess whitespace off the beginning and end of a string * * @param {String} str The String to trim * @returns {String} The String freed of excess whitespace */ function trim(str) { return str.replace(/^\s*/, '').replace(/\s*$/, ''); } /** * Determine if we're running in a standard browser environment * * This allows axios to run in a web worker, and react-native. * Both environments support XMLHttpRequest, but not fully standard globals. * * web workers: * typeof window -> undefined * typeof document -> undefined * * react-native: * navigator.product -> 'ReactNative' */ function isStandardBrowserEnv() { if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') { return false; } return ( typeof window !== 'undefined' && typeof document !== 'undefined' ); } /** * Iterate over an Array or an Object invoking a function for each item. * * If `obj` is an Array callback will be called passing * the value, index, and complete array for each item. * * If 'obj' is an Object callback will be called passing * the value, key, and complete object for each property. * * @param {Object|Array} obj The object to iterate * @param {Function} fn The callback to invoke for each item */ function forEach(obj, fn) { // Don't bother if no value provided if (obj === null || typeof obj === 'undefined') { return; } // Force an array if not already something iterable if (typeof obj !== 'object' && !isArray(obj)) { /*eslint no-param-reassign:0*/ obj = [obj]; } if (isArray(obj)) { // Iterate over array values for (var i = 0, l = obj.length; i < l; i++) { fn.call(null, obj[i], i, obj); } } else { // Iterate over object keys for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { fn.call(null, obj[key], key, obj); } } } } /** * Accepts varargs expecting each argument to be an object, then * immutably merges the properties of each object and returns result. * * When multiple objects contain the same key the later object in * the arguments list will take precedence. * * Example: * * ```js * var result = merge({foo: 123}, {foo: 456}); * console.log(result.foo); // outputs 456 * ``` * * @param {Object} obj1 Object to merge * @returns {Object} Result of all merge properties */ function merge(/* obj1, obj2, obj3, ... */) { var result = {}; function assignValue(val, key) { if (typeof result[key] === 'object' && typeof val === 'object') { result[key] = merge(result[key], val); } else { result[key] = val; } } for (var i = 0, l = arguments.length; i < l; i++) { forEach(arguments[i], assignValue); } return result; } /** * Extends object a by mutably adding to it the properties of object b. * * @param {Object} a The object to be extended * @param {Object} b The object to copy properties from * @param {Object} thisArg The object to bind function to * @return {Object} The resulting value of object a */ function extend(a, b, thisArg) { forEach(b, function assignValue(val, key) { if (thisArg && typeof val === 'function') { a[key] = bind(val, thisArg); } else { a[key] = val; } }); return a; } module.exports = { isArray: isArray, isArrayBuffer: isArrayBuffer, isBuffer: isBuffer, isFormData: isFormData, isArrayBufferView: isArrayBufferView, isString: isString, isNumber: isNumber, isObject: isObject, isUndefined: isUndefined, isDate: isDate, isFile: isFile, isBlob: isBlob, isFunction: isFunction, isStream: isStream, isURLSearchParams: isURLSearchParams, isStandardBrowserEnv: isStandardBrowserEnv, forEach: forEach, merge: merge, extend: extend, trim: trim }; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer)) /***/ }, /* 3 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/*! * The buffer module from node.js, for the browser. * * @author Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license MIT */ /* eslint-disable no-proto */ 'use strict' var base64 = __webpack_require__(4) var ieee754 = __webpack_require__(5) var isArray = __webpack_require__(6) exports.Buffer = Buffer exports.SlowBuffer = SlowBuffer exports.INSPECT_MAX_BYTES = 50 /** * If `Buffer.TYPED_ARRAY_SUPPORT`: * === true Use Uint8Array implementation (fastest) * === false Use Object implementation (most compatible, even IE6) * * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+, * Opera 11.6+, iOS 4.2+. * * Due to various browser bugs, sometimes the Object implementation will be used even * when the browser supports typed arrays. * * Note: * * - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances, * See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438. * * - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function. * * - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of * incorrect length in some situations. * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they * get the Object implementation, which is slower but behaves correctly. */ Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport() /* * Export kMaxLength after typed array support is determined. */ exports.kMaxLength = kMaxLength() function typedArraySupport () { try { var arr = new Uint8Array(1) arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }} return arr.foo() === 42 && // typed array instances can be augmented typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray` arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray` } catch (e) { return false } } function kMaxLength () { return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff } function createBuffer (that, length) { if (kMaxLength() < length) { throw new RangeError('Invalid typed array length') } if (Buffer.TYPED_ARRAY_SUPPORT) { // Return an augmented `Uint8Array` instance, for best performance that = new Uint8Array(length) that.__proto__ = Buffer.prototype } else { // Fallback: Return an object instance of the Buffer class if (that === null) { that = new Buffer(length) } that.length = length } return that } /** * The Buffer constructor returns instances of `Uint8Array` that have their * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of * `Uint8Array`, so the returned instances will have all the node `Buffer` methods * and the `Uint8Array` methods. Square bracket notation works as expected -- it * returns a single octet. * * The `Uint8Array` prototype remains unmodified. */ function Buffer (arg, encodingOrOffset, length) { if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) { return new Buffer(arg, encodingOrOffset, length) } // Common case. if (typeof arg === 'number') { if (typeof encodingOrOffset === 'string') { throw new Error( 'If encoding is specified then the first argument must be a string' ) } return allocUnsafe(this, arg) } return from(this, arg, encodingOrOffset, length) } Buffer.poolSize = 8192 // not used by this implementation // TODO: Legacy, not needed anymore. Remove in next major version. Buffer._augment = function (arr) { arr.__proto__ = Buffer.prototype return arr } function from (that, value, encodingOrOffset, length) { if (typeof value === 'number') { throw new TypeError('"value" argument must not be a number') } if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) { return fromArrayBuffer(that, value, encodingOrOffset, length) } if (typeof value === 'string') { return fromString(that, value, encodingOrOffset) } return fromObject(that, value) } /** * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError * if value is a number. * Buffer.from(str[, encoding]) * Buffer.from(array) * Buffer.from(buffer) * Buffer.from(arrayBuffer[, byteOffset[, length]]) **/ Buffer.from = function (value, encodingOrOffset, length) { return from(null, value, encodingOrOffset, length) } if (Buffer.TYPED_ARRAY_SUPPORT) { Buffer.prototype.__proto__ = Uint8Array.prototype Buffer.__proto__ = Uint8Array if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) { // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97 Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: true }) } } function assertSize (size) { if (typeof size !== 'number') { throw new TypeError('"size" argument must be a number') } else if (size < 0) { throw new RangeError('"size" argument must not be negative') } } function alloc (that, size, fill, encoding) { assertSize(size) if (size <= 0) { return createBuffer(that, size) } if (fill !== undefined) { // Only pay attention to encoding if it's a string. This // prevents accidentally sending in a number that would // be interpretted as a start offset. return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill) } return createBuffer(that, size) } /** * Creates a new filled Buffer instance. * alloc(size[, fill[, encoding]]) **/ Buffer.alloc = function (size, fill, encoding) { return alloc(null, size, fill, encoding) } function allocUnsafe (that, size) { assertSize(size) that = createBuffer(that, size < 0 ? 0 : checked(size) | 0) if (!Buffer.TYPED_ARRAY_SUPPORT) { for (var i = 0; i < size; ++i) { that[i] = 0 } } return that } /** * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance. * */ Buffer.allocUnsafe = function (size) { return allocUnsafe(null, size) } /** * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance. */ Buffer.allocUnsafeSlow = function (size) { return allocUnsafe(null, size) } function fromString (that, string, encoding) { if (typeof encoding !== 'string' || encoding === '') { encoding = 'utf8' } if (!Buffer.isEncoding(encoding)) { throw new TypeError('"encoding" must be a valid string encoding') } var length = byteLength(string, encoding) | 0 that = createBuffer(that, length) var actual = that.write(string, encoding) if (actual !== length) { // Writing a hex string, for example, that contains invalid characters will // cause everything after the first invalid character to be ignored. (e.g. // 'abxxcd' will be treated as 'ab') that = that.slice(0, actual) } return that } function fromArrayLike (that, array) { var length = array.length < 0 ? 0 : checked(array.length) | 0 that = createBuffer(that, length) for (var i = 0; i < length; i += 1) { that[i] = array[i] & 255 } return that } function fromArrayBuffer (that, array, byteOffset, length) { array.byteLength // this throws if `array` is not a valid ArrayBuffer if (byteOffset < 0 || array.byteLength < byteOffset) { throw new RangeError('\'offset\' is out of bounds') } if (array.byteLength < byteOffset + (length || 0)) { throw new RangeError('\'length\' is out of bounds') } if (byteOffset === undefined && length === undefined) { array = new Uint8Array(array) } else if (length === undefined) { array = new Uint8Array(array, byteOffset) } else { array = new Uint8Array(array, byteOffset, length) } if (Buffer.TYPED_ARRAY_SUPPORT) { // Return an augmented `Uint8Array` instance, for best performance that = array that.__proto__ = Buffer.prototype } else { // Fallback: Return an object instance of the Buffer class that = fromArrayLike(that, array) } return that } function fromObject (that, obj) { if (Buffer.isBuffer(obj)) { var len = checked(obj.length) | 0 that = createBuffer(that, len) if (that.length === 0) { return that } obj.copy(that, 0, 0, len) return that } if (obj) { if ((typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer) || 'length' in obj) { if (typeof obj.length !== 'number' || isnan(obj.length)) { return createBuffer(that, 0) } return fromArrayLike(that, obj) } if (obj.type === 'Buffer' && isArray(obj.data)) { return fromArrayLike(that, obj.data) } } throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.') } function checked (length) { // Note: cannot use `length < kMaxLength()` here because that fails when // length is NaN (which is otherwise coerced to zero.) if (length >= kMaxLength()) { throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes') } return length | 0 } function SlowBuffer (length) { if (+length != length) { // eslint-disable-line eqeqeq length = 0 } return Buffer.alloc(+length) } Buffer.isBuffer = function isBuffer (b) { return !!(b != null && b._isBuffer) } Buffer.compare = function compare (a, b) { if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) { throw new TypeError('Arguments must be Buffers') } if (a === b) return 0 var x = a.length var y = b.length for (var i = 0, len = Math.min(x, y); i < len; ++i) { if (a[i] !== b[i]) { x = a[i] y = b[i] break } } if (x < y) return -1 if (y < x) return 1 return 0 } Buffer.isEncoding = function isEncoding (encoding) { switch (String(encoding).toLowerCase()) { case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'latin1': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return true default: return false } } Buffer.concat = function concat (list, length) { if (!isArray(list)) { throw new TypeError('"list" argument must be an Array of Buffers') } if (list.length === 0) { return Buffer.alloc(0) } var i if (length === undefined) { length = 0 for (i = 0; i < list.length; ++i) { length += list[i].length } } var buffer = Buffer.allocUnsafe(length) var pos = 0 for (i = 0; i < list.length; ++i) { var buf = list[i] if (!Buffer.isBuffer(buf)) { throw new TypeError('"list" argument must be an Array of Buffers') } buf.copy(buffer, pos) pos += buf.length } return buffer } function byteLength (string, encoding) { if (Buffer.isBuffer(string)) { return string.length } if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) { return string.byteLength } if (typeof string !== 'string') { string = '' + string } var len = string.length if (len === 0) return 0 // Use a for loop to avoid recursion var loweredCase = false for (;;) { switch (encoding) { case 'ascii': case 'latin1': case 'binary': return len case 'utf8': case 'utf-8': case undefined: return utf8ToBytes(string).length case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return len * 2 case 'hex': return len >>> 1 case 'base64': return base64ToBytes(string).length default: if (loweredCase) return utf8ToBytes(string).length // assume utf8 encoding = ('' + encoding).toLowerCase() loweredCase = true } } } Buffer.byteLength = byteLength function slowToString (encoding, start, end) { var loweredCase = false // No need to verify that "this.length <= MAX_UINT32" since it's a read-only // property of a typed array. // This behaves neither like String nor Uint8Array in that we set start/end // to their upper/lower bounds if the value passed is out of range. // undefined is handled specially as per ECMA-262 6th Edition, // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization. if (start === undefined || start < 0) { start = 0 } // Return early if start > this.length. Done here to prevent potential uint32 // coercion fail below. if (start > this.length) { return '' } if (end === undefined || end > this.length) { end = this.length } if (end <= 0) { return '' } // Force coersion to uint32. This will also coerce falsey/NaN values to 0. end >>>= 0 start >>>= 0 if (end <= start) { return '' } if (!encoding) encoding = 'utf8' while (true) { switch (encoding) { case 'hex': return hexSlice(this, start, end) case 'utf8': case 'utf-8': return utf8Slice(this, start, end) case 'ascii': return asciiSlice(this, start, end) case 'latin1': case 'binary': return latin1Slice(this, start, end) case 'base64': return base64Slice(this, start, end) case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return utf16leSlice(this, start, end) default: if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding) encoding = (encoding + '').toLowerCase() loweredCase = true } } } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect // Buffer instances. Buffer.prototype._isBuffer = true function swap (b, n, m) { var i = b[n] b[n] = b[m] b[m] = i } Buffer.prototype.swap16 = function swap16 () { var len = this.length if (len % 2 !== 0) { throw new RangeError('Buffer size must be a multiple of 16-bits') } for (var i = 0; i < len; i += 2) { swap(this, i, i + 1) } return this } Buffer.prototype.swap32 = function swap32 () { var len = this.length if (len % 4 !== 0) { throw new RangeError('Buffer size must be a multiple of 32-bits') } for (var i = 0; i < len; i += 4) { swap(this, i, i + 3) swap(this, i + 1, i + 2) } return this } Buffer.prototype.swap64 = function swap64 () { var len = this.length if (len % 8 !== 0) { throw new RangeError('Buffer size must be a multiple of 64-bits') } for (var i = 0; i < len; i += 8) { swap(this, i, i + 7) swap(this, i + 1, i + 6) swap(this, i + 2, i + 5) swap(this, i + 3, i + 4) } return this } Buffer.prototype.toString = function toString () { var length = this.length | 0 if (length === 0) return '' if (arguments.length === 0) return utf8Slice(this, 0, length) return slowToString.apply(this, arguments) } Buffer.prototype.equals = function equals (b) { if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer') if (this === b) return true return Buffer.compare(this, b) === 0 } Buffer.prototype.inspect = function inspect () { var str = '' var max = exports.INSPECT_MAX_BYTES if (this.length > 0) { str = this.toString('hex', 0, max).match(/.{2}/g).join(' ') if (this.length > max) str += ' ... ' } return '<Buffer ' + str + '>' } Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) { if (!Buffer.isBuffer(target)) { throw new TypeError('Argument must be a Buffer') } if (start === undefined) { start = 0 } if (end === undefined) { end = target ? target.length : 0 } if (thisStart === undefined) { thisStart = 0 } if (thisEnd === undefined) { thisEnd = this.length } if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) { throw new RangeError('out of range index') } if (thisStart >= thisEnd && start >= end) { return 0 } if (thisStart >= thisEnd) { return -1 } if (start >= end) { return 1 } start >>>= 0 end >>>= 0 thisStart >>>= 0 thisEnd >>>= 0 if (this === target) return 0 var x = thisEnd - thisStart var y = end - start var len = Math.min(x, y) var thisCopy = this.slice(thisStart, thisEnd) var targetCopy = target.slice(start, end) for (var i = 0; i < len; ++i) { if (thisCopy[i] !== targetCopy[i]) { x = thisCopy[i] y = targetCopy[i] break } } if (x < y) return -1 if (y < x) return 1 return 0 } // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`, // OR the last index of `val` in `buffer` at offset <= `byteOffset`. // // Arguments: // - buffer - a Buffer to search // - val - a string, Buffer, or number // - byteOffset - an index into `buffer`; will be clamped to an int32 // - encoding - an optional encoding, relevant is val is a string // - dir - true for indexOf, false for lastIndexOf function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) { // Empty buffer means no match if (buffer.length === 0) return -1 // Normalize byteOffset if (typeof byteOffset === 'string') { encoding = byteOffset byteOffset = 0 } else if (byteOffset > 0x7fffffff) { byteOffset = 0x7fffffff } else if (byteOffset < -0x80000000) { byteOffset = -0x80000000 } byteOffset = +byteOffset // Coerce to Number. if (isNaN(byteOffset)) { // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer byteOffset = dir ? 0 : (buffer.length - 1) } // Normalize byteOffset: negative offsets start from the end of the buffer if (byteOffset < 0) byteOffset = buffer.length + byteOffset if (byteOffset >= buffer.length) { if (dir) return -1 else byteOffset = buffer.length - 1 } else if (byteOffset < 0) { if (dir) byteOffset = 0 else return -1 } // Normalize val if (typeof val === 'string') { val = Buffer.from(val, encoding) } // Finally, search either indexOf (if dir is true) or lastIndexOf if (Buffer.isBuffer(val)) { // Special case: looking for empty string/buffer always fails if (val.length === 0) { return -1 } return arrayIndexOf(buffer, val, byteOffset, encoding, dir) } else if (typeof val === 'number') { val = val & 0xFF // Search for a byte value [0-255] if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') { if (dir) { return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) } else { return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) } } return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir) } throw new TypeError('val must be string, number or Buffer') } function arrayIndexOf (arr, val, byteOffset, encoding, dir) { var indexSize = 1 var arrLength = arr.length var valLength = val.length if (encoding !== undefined) { encoding = String(encoding).toLowerCase() if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') { if (arr.length < 2 || val.length < 2) { return -1 } indexSize = 2 arrLength /= 2 valLength /= 2 byteOffset /= 2 } } function read (buf, i) { if (indexSize === 1) { return buf[i] } else { return buf.readUInt16BE(i * indexSize) } } var i if (dir) { var foundIndex = -1 for (i = byteOffset; i < arrLength; i++) { if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) { if (foundIndex === -1) foundIndex = i if (i - foundIndex + 1 === valLength) return foundIndex * indexSize } else { if (foundIndex !== -1) i -= i - foundIndex foundIndex = -1 } } } else { if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength for (i = byteOffset; i >= 0; i--) { var found = true for (var j = 0; j < valLength; j++) { if (read(arr, i + j) !== read(val, j)) { found = false break } } if (found) return i } } return -1 } Buffer.prototype.includes = function includes (val, byteOffset, encoding) { return this.indexOf(val, byteOffset, encoding) !== -1 } Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, true) } Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, false) } function hexWrite (buf, string, offset, length) { offset = Number(offset) || 0 var remaining = buf.length - offset if (!length) { length = remaining } else { length = Number(length) if (length > remaining) { length = remaining } } // must be an even number of digits var strLen = string.length if (strLen % 2 !== 0) throw new TypeError('Invalid hex string') if (length > strLen / 2) { length = strLen / 2 } for (var i = 0; i < length; ++i) { var parsed = parseInt(string.substr(i * 2, 2), 16) if (isNaN(parsed)) return i buf[offset + i] = parsed } return i } function utf8Write (buf, string, offset, length) { return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length) } function asciiWrite (buf, string, offset, length) { return blitBuffer(asciiToBytes(string), buf, offset, length) } function latin1Write (buf, string, offset, length) { return asciiWrite(buf, string, offset, length) } function base64Write (buf, string, offset, length) { return blitBuffer(base64ToBytes(string), buf, offset, length) } function ucs2Write (buf, string, offset, length) { return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length) } Buffer.prototype.write = function write (string, offset, length, encoding) { // Buffer#write(string) if (offset === undefined) { encoding = 'utf8' length = this.length offset = 0 // Buffer#write(string, encoding) } else if (length === undefined && typeof offset === 'string') { encoding = offset length = this.length offset = 0 // Buffer#write(string, offset[, length][, encoding]) } else if (isFinite(offset)) { offset = offset | 0 if (isFinite(length)) { length = length | 0 if (encoding === undefined) encoding = 'utf8' } else { encoding = length length = undefined } // legacy write(string, encoding, offset, length) - remove in v0.13 } else { throw new Error( 'Buffer.write(string, encoding, offset[, length]) is no longer supported' ) } var remaining = this.length - offset if (length === undefined || length > remaining) length = remaining if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) { throw new RangeError('Attempt to write outside buffer bounds') } if (!encoding) encoding = 'utf8' var loweredCase = false for (;;) { switch (encoding) { case 'hex': return hexWrite(this, string, offset, length) case 'utf8': case 'utf-8': return utf8Write(this, string, offset, length) case 'ascii': return asciiWrite(this, string, offset, length) case 'latin1': case 'binary': return latin1Write(this, string, offset, length) case 'base64': // Warning: maxLength not taken into account in base64Write return base64Write(this, string, offset, length) case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return ucs2Write(this, string, offset, length) default: if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding) encoding = ('' + encoding).toLowerCase() loweredCase = true } } } Buffer.prototype.toJSON = function toJSON () { return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) } } function base64Slice (buf, start, end) { if (start === 0 && end === buf.length) { return base64.fromByteArray(buf) } else { return base64.fromByteArray(buf.slice(start, end)) } } function utf8Slice (buf, start, end) { end = Math.min(buf.length, end) var res = [] var i = start while (i < end) { var firstByte = buf[i] var codePoint = null var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1 if (i + bytesPerSequence <= end) { var secondByte, thirdByte, fourthByte, tempCodePoint switch (bytesPerSequence) { case 1: if (firstByte < 0x80) { codePoint = firstByte } break case 2: secondByte = buf[i + 1] if ((secondByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F) if (tempCodePoint > 0x7F) { codePoint = tempCodePoint } } break case 3: secondByte = buf[i + 1] thirdByte = buf[i + 2] if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F) if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) { codePoint = tempCodePoint } } break case 4: secondByte = buf[i + 1] thirdByte = buf[i + 2] fourthByte = buf[i + 3] if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F) if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) { codePoint = tempCodePoint } } } } if (codePoint === null) { // we did not generate a valid codePoint so insert a // replacement char (U+FFFD) and advance only 1 byte codePoint = 0xFFFD bytesPerSequence = 1 } else if (codePoint > 0xFFFF) { // encode to utf16 (surrogate pair dance) codePoint -= 0x10000 res.push(codePoint >>> 10 & 0x3FF | 0xD800) codePoint = 0xDC00 | codePoint & 0x3FF } res.push(codePoint) i += bytesPerSequence } return decodeCodePointsArray(res) } // Based on http://stackoverflow.com/a/22747272/680742, the browser with // the lowest limit is Chrome, with 0x10000 args. // We go 1 magnitude less, for safety var MAX_ARGUMENTS_LENGTH = 0x1000 function decodeCodePointsArray (codePoints) { var len = codePoints.length if (len <= MAX_ARGUMENTS_LENGTH) { return String.fromCharCode.apply(String, codePoints) // avoid extra slice() } // Decode in chunks to avoid "call stack size exceeded". var res = '' var i = 0 while (i < len) { res += String.fromCharCode.apply( String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH) ) } return res } function asciiSlice (buf, start, end) { var ret = '' end = Math.min(buf.length, end) for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i] & 0x7F) } return ret } function latin1Slice (buf, start, end) { var ret = '' end = Math.min(buf.length, end) for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i]) } return ret } function hexSlice (buf, start, end) { var len = buf.length if (!start || start < 0) start = 0 if (!end || end < 0 || end > len) end = len var out = '' for (var i = start; i < end; ++i) { out += toHex(buf[i]) } return out } function utf16leSlice (buf, start, end) { var bytes = buf.slice(start, end) var res = '' for (var i = 0; i < bytes.length; i += 2) { res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256) } return res } Buffer.prototype.slice = function slice (start, end) { var len = this.length start = ~~start end = end === undefined ? len : ~~end if (start < 0) { start += len if (start < 0) start = 0 } else if (start > len) { start = len } if (end < 0) { end += len if (end < 0) end = 0 } else if (end > len) { end = len } if (end < start) end = start var newBuf if (Buffer.TYPED_ARRAY_SUPPORT) { newBuf = this.subarray(start, end) newBuf.__proto__ = Buffer.prototype } else { var sliceLen = end - start newBuf = new Buffer(sliceLen, undefined) for (var i = 0; i < sliceLen; ++i) { newBuf[i] = this[i + start] } } return newBuf } /* * Need to make sure that buffer isn't trying to write out of bounds. */ function checkOffset (offset, ext, length) { if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint') if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length') } Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var val = this[offset] var mul = 1 var i = 0 while (++i < byteLength && (mul *= 0x100)) { val += this[offset + i] * mul } return val } Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { checkOffset(offset, byteLength, this.length) } var val = this[offset + --byteLength] var mul = 1 while (byteLength > 0 && (mul *= 0x100)) { val += this[offset + --byteLength] * mul } return val } Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length) return this[offset] } Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) return this[offset] | (this[offset + 1] << 8) } Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) return (this[offset] << 8) | this[offset + 1] } Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000) } Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]) } Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var val = this[offset] var mul = 1 var i = 0 while (++i < byteLength && (mul *= 0x100)) { val += this[offset + i] * mul } mul *= 0x80 if (val >= mul) val -= Math.pow(2, 8 * byteLength) return val } Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var i = byteLength var mul = 1 var val = this[offset + --i] while (i > 0 && (mul *= 0x100)) { val += this[offset + --i] * mul } mul *= 0x80 if (val >= mul) val -= Math.pow(2, 8 * byteLength) return val } Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length) if (!(this[offset] & 0x80)) return (this[offset]) return ((0xff - this[offset] + 1) * -1) } Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) var val = this[offset] | (this[offset + 1] << 8) return (val & 0x8000) ? val | 0xFFFF0000 : val } Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) var val = this[offset + 1] | (this[offset] << 8) return (val & 0x8000) ? val | 0xFFFF0000 : val } Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24) } Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]) } Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ieee754.read(this, offset, true, 23, 4) } Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ieee754.read(this, offset, false, 23, 4) } Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length) return ieee754.read(this, offset, true, 52, 8) } Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length) return ieee754.read(this, offset, false, 52, 8) } function checkInt (buf, value, offset, ext, max, min) { if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance') if (value > max || value < min) throw new RangeError('"value" argument is out of bounds') if (offset + ext > buf.length) throw new RangeError('Index out of range') } Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1 checkInt(this, value, offset, byteLength, maxBytes, 0) } var mul = 1 var i = 0 this[offset] = value & 0xFF while (++i < byteLength && (mul *= 0x100)) { this[offset + i] = (value / mul) & 0xFF } return offset + byteLength } Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1 checkInt(this, value, offset, byteLength, maxBytes, 0) } var i = byteLength - 1 var mul = 1 this[offset + i] = value & 0xFF while (--i >= 0 && (mul *= 0x100)) { this[offset + i] = (value / mul) & 0xFF } return offset + byteLength } Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0) if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value) this[offset] = (value & 0xff) return offset + 1 } function objectWriteUInt16 (buf, value, offset, littleEndian) { if (value < 0) value = 0xffff + value + 1 for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) { buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8 } } Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 } Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 8) this[offset + 1] = (value & 0xff) } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 } function objectWriteUInt32 (buf, value, offset, littleEndian) { if (value < 0) value = 0xffffffff + value + 1 for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) { buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff } } Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset + 3] = (value >>> 24) this[offset + 2] = (value >>> 16) this[offset + 1] = (value >>> 8) this[offset] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 } Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 24) this[offset + 1] = (value >>> 16) this[offset + 2] = (value >>> 8) this[offset + 3] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 } Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1) checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = 0 var mul = 1 var sub = 0 this[offset] = value & 0xFF while (++i < byteLength && (mul *= 0x100)) { if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) { sub = 1 } this[offset + i] = ((value / mul) >> 0) - sub & 0xFF } return offset + byteLength } Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1) checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = byteLength - 1 var mul = 1 var sub = 0 this[offset + i] = value & 0xFF while (--i >= 0 && (mul *= 0x100)) { if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) { sub = 1 } this[offset + i] = ((value / mul) >> 0) - sub & 0xFF } return offset + byteLength } Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80) if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value) if (value < 0) value = 0xff + value + 1 this[offset] = (value & 0xff) return offset + 1 } Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 } Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 8) this[offset + 1] = (value & 0xff) } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 } Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) this[offset + 2] = (value >>> 16) this[offset + 3] = (value >>> 24) } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 } Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000) if (value < 0) value = 0xffffffff + value + 1 if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 24) this[offset + 1] = (value >>> 16) this[offset + 2] = (value >>> 8) this[offset + 3] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 } function checkIEEE754 (buf, value, offset, ext, max, min) { if (offset + ext > buf.length) throw new RangeError('Index out of range') if (offset < 0) throw new RangeError('Index out of range') } function writeFloat (buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38) } ieee754.write(buf, value, offset, littleEndian, 23, 4) return offset + 4 } Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) { return writeFloat(this, value, offset, true, noAssert) } Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) { return writeFloat(this, value, offset, false, noAssert) } function writeDouble (buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308) } ieee754.write(buf, value, offset, littleEndian, 52, 8) return offset + 8 } Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) { return writeDouble(this, value, offset, true, noAssert) } Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) { return writeDouble(this, value, offset, false, noAssert) } // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length) Buffer.prototype.copy = function copy (target, targetStart, start, end) { if (!start) start = 0 if (!end && end !== 0) end = this.length if (targetStart >= target.length) targetStart = target.length if (!targetStart) targetStart = 0 if (end > 0 && end < start) end = start // Copy 0 bytes; we're done if (end === start) return 0 if (target.length === 0 || this.length === 0) return 0 // Fatal error conditions if (targetStart < 0) { throw new RangeError('targetStart out of bounds') } if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds') if (end < 0) throw new RangeError('sourceEnd out of bounds') // Are we oob? if (end > this.length) end = this.length if (target.length - targetStart < end - start) { end = target.length - targetStart + start } var len = end - start var i if (this === target && start < targetStart && targetStart < end) { // descending copy from end for (i = len - 1; i >= 0; --i) { target[i + targetStart] = this[i + start] } } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) { // ascending copy from start for (i = 0; i < len; ++i) { target[i + targetStart] = this[i + start] } } else { Uint8Array.prototype.set.call( target, this.subarray(start, start + len), targetStart ) } return len } // Usage: // buffer.fill(number[, offset[, end]]) // buffer.fill(buffer[, offset[, end]]) // buffer.fill(string[, offset[, end]][, encoding]) Buffer.prototype.fill = function fill (val, start, end, encoding) { // Handle string cases: if (typeof val === 'string') { if (typeof start === 'string') { encoding = start start = 0 end = this.length } else if (typeof end === 'string') { encoding = end end = this.length } if (val.length === 1) { var code = val.charCodeAt(0) if (code < 256) { val = code } } if (encoding !== undefined && typeof encoding !== 'string') { throw new TypeError('encoding must be a string') } if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) { throw new TypeError('Unknown encoding: ' + encoding) } } else if (typeof val === 'number') { val = val & 255 } // Invalid ranges are not set to a default, so can range check early. if (start < 0 || this.length < start || this.length < end) { throw new RangeError('Out of range index') } if (end <= start) { return this } start = start >>> 0 end = end === undefined ? this.length : end >>> 0 if (!val) val = 0 var i if (typeof val === 'number') { for (i = start; i < end; ++i) { this[i] = val } } else { var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString()) var len = bytes.length for (i = 0; i < end - start; ++i) { this[i + start] = bytes[i % len] } } return this } // HELPER FUNCTIONS // ================ var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g function base64clean (str) { // Node strips out invalid characters like \n and \t from the string, base64-js does not str = stringtrim(str).replace(INVALID_BASE64_RE, '') // Node converts strings with length < 2 to '' if (str.length < 2) return '' // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not while (str.length % 4 !== 0) { str = str + '=' } return str } function stringtrim (str) { if (str.trim) return str.trim() return str.replace(/^\s+|\s+$/g, '') } function toHex (n) { if (n < 16) return '0' + n.toString(16) return n.toString(16) } function utf8ToBytes (string, units) { units = units || Infinity var codePoint var length = string.length var leadSurrogate = null var bytes = [] for (var i = 0; i < length; ++i) { codePoint = string.charCodeAt(i) // is surrogate component if (codePoint > 0xD7FF && codePoint < 0xE000) { // last char was a lead if (!leadSurrogate) { // no lead yet if (codePoint > 0xDBFF) { // unexpected trail if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) continue } else if (i + 1 === length) { // unpaired lead if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) continue } // valid lead leadSurrogate = codePoint continue } // 2 leads in a row if (codePoint < 0xDC00) { if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) leadSurrogate = codePoint continue } // valid surrogate pair codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000 } else if (leadSurrogate) { // valid bmp char, but last char was a lead if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) } leadSurrogate = null // encode utf8 if (codePoint < 0x80) { if ((units -= 1) < 0) break bytes.push(codePoint) } else if (codePoint < 0x800) { if ((units -= 2) < 0) break bytes.push( codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80 ) } else if (codePoint < 0x10000) { if ((units -= 3) < 0) break bytes.push( codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80 ) } else if (codePoint < 0x110000) { if ((units -= 4) < 0) break bytes.push( codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80 ) } else { throw new Error('Invalid code point') } } return bytes } function asciiToBytes (str) { var byteArray = [] for (var i = 0; i < str.length; ++i) { // Node's code seems to be doing this and not & 0x7F.. byteArray.push(str.charCodeAt(i) & 0xFF) } return byteArray } function utf16leToBytes (str, units) { var c, hi, lo var byteArray = [] for (var i = 0; i < str.length; ++i) { if ((units -= 2) < 0) break c = str.charCodeAt(i) hi = c >> 8 lo = c % 256 byteArray.push(lo) byteArray.push(hi) } return byteArray } function base64ToBytes (str) { return base64.toByteArray(base64clean(str)) } function blitBuffer (src, dst, offset, length) { for (var i = 0; i < length; ++i) { if ((i + offset >= dst.length) || (i >= src.length)) break dst[i + offset] = src[i] } return i } function isnan (val) { return val !== val // eslint-disable-line no-self-compare } /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }, /* 4 */ /***/ function(module, exports) { 'use strict' exports.byteLength = byteLength exports.toByteArray = toByteArray exports.fromByteArray = fromByteArray var lookup = [] var revLookup = [] var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' for (var i = 0, len = code.length; i < len; ++i) { lookup[i] = code[i] revLookup[code.charCodeAt(i)] = i } revLookup['-'.charCodeAt(0)] = 62 revLookup['_'.charCodeAt(0)] = 63 function placeHoldersCount (b64) { var len = b64.length if (len % 4 > 0) { throw new Error('Invalid string. Length must be a multiple of 4') } // the number of equal signs (place holders) // if there are two placeholders, than the two characters before it // represent one byte // if there is only one, then the three characters before it represent 2 bytes // this is just a cheap hack to not do indexOf twice return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0 } function byteLength (b64) { // base64 is 4/3 + up to two characters of the original data return b64.length * 3 / 4 - placeHoldersCount(b64) } function toByteArray (b64) { var i, j, l, tmp, placeHolders, arr var len = b64.length placeHolders = placeHoldersCount(b64) arr = new Arr(len * 3 / 4 - placeHolders) // if there are placeholders, only get up to the last complete 4 chars l = placeHolders > 0 ? len - 4 : len var L = 0 for (i = 0, j = 0; i < l; i += 4, j += 3) { tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)] arr[L++] = (tmp >> 16) & 0xFF arr[L++] = (tmp >> 8) & 0xFF arr[L++] = tmp & 0xFF } if (placeHolders === 2) { tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4) arr[L++] = tmp & 0xFF } else if (placeHolders === 1) { tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2) arr[L++] = (tmp >> 8) & 0xFF arr[L++] = tmp & 0xFF } return arr } function tripletToBase64 (num) { return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F] } function encodeChunk (uint8, start, end) { var tmp var output = [] for (var i = start; i < end; i += 3) { tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]) output.push(tripletToBase64(tmp)) } return output.join('') } function fromByteArray (uint8) { var tmp var len = uint8.length var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes var output = '' var parts = [] var maxChunkLength = 16383 // must be multiple of 3 // go through the array every three bytes, we'll deal with trailing stuff later for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) { parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength))) } // pad the end with zeros, but make sure to not forget the extra bytes if (extraBytes === 1) { tmp = uint8[len - 1] output += lookup[tmp >> 2] output += lookup[(tmp << 4) & 0x3F] output += '==' } else if (extraBytes === 2) { tmp = (uint8[len - 2] << 8) + (uint8[len - 1]) output += lookup[tmp >> 10] output += lookup[(tmp >> 4) & 0x3F] output += lookup[(tmp << 2) & 0x3F] output += '=' } parts.push(output) return parts.join('') } /***/ }, /* 5 */ /***/ function(module, exports) { exports.read = function (buffer, offset, isLE, mLen, nBytes) { var e, m var eLen = nBytes * 8 - mLen - 1 var eMax = (1 << eLen) - 1 var eBias = eMax >> 1 var nBits = -7 var i = isLE ? (nBytes - 1) : 0 var d = isLE ? -1 : 1 var s = buffer[offset + i] i += d e = s & ((1 << (-nBits)) - 1) s >>= (-nBits) nBits += eLen for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {} m = e & ((1 << (-nBits)) - 1) e >>= (-nBits) nBits += mLen for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {} if (e === 0) { e = 1 - eBias } else if (e === eMax) { return m ? NaN : ((s ? -1 : 1) * Infinity) } else { m = m + Math.pow(2, mLen) e = e - eBias } return (s ? -1 : 1) * m * Math.pow(2, e - mLen) } exports.write = function (buffer, value, offset, isLE, mLen, nBytes) { var e, m, c var eLen = nBytes * 8 - mLen - 1 var eMax = (1 << eLen) - 1 var eBias = eMax >> 1 var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0) var i = isLE ? 0 : (nBytes - 1) var d = isLE ? 1 : -1 var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0 value = Math.abs(value) if (isNaN(value) || value === Infinity) { m = isNaN(value) ? 1 : 0 e = eMax } else { e = Math.floor(Math.log(value) / Math.LN2) if (value * (c = Math.pow(2, -e)) < 1) { e-- c *= 2 } if (e + eBias >= 1) { value += rt / c } else { value += rt * Math.pow(2, 1 - eBias) } if (value * c >= 2) { e++ c /= 2 } if (e + eBias >= eMax) { m = 0 e = eMax } else if (e + eBias >= 1) { m = (value * c - 1) * Math.pow(2, mLen) e = e + eBias } else { m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen) e = 0 } } for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {} e = (e << mLen) | m eLen += mLen for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {} buffer[offset + i - d] |= s * 128 } /***/ }, /* 6 */ /***/ function(module, exports) { var toString = {}.toString; module.exports = Array.isArray || function (arr) { return toString.call(arr) == '[object Array]'; }; /***/ }, /* 7 */ /***/ function(module, exports) { 'use strict'; module.exports = function bind(fn, thisArg) { return function wrap() { var args = new Array(arguments.length); for (var i = 0; i < args.length; i++) { args[i] = arguments[i]; } return fn.apply(thisArg, args); }; }; /***/ }, /* 8 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var defaults = __webpack_require__(9); var utils = __webpack_require__(2); var InterceptorManager = __webpack_require__(20); var dispatchRequest = __webpack_require__(21); var isAbsoluteURL = __webpack_require__(24); var combineURLs = __webpack_require__(25); /** * Create a new instance of Axios * * @param {Object} instanceConfig The default config for the instance */ function Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() }; } /** * Dispatch a request * * @param {Object} config The config specific for this request (merged with this.defaults) */ Axios.prototype.request = function request(config) { /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API if (typeof config === 'string') { config = utils.merge({ url: arguments[0] }, arguments[1]); } config = utils.merge(defaults, this.defaults, { method: 'get' }, config); // Support baseURL config if (config.baseURL && !isAbsoluteURL(config.url)) { config.url = combineURLs(config.baseURL, config.url); } // Hook up interceptors middleware var chain = [dispatchRequest, undefined]; var promise = Promise.resolve(config); this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected); }); this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected); }); while (chain.length) { promise = promise.then(chain.shift(), chain.shift()); } return promise; }; // Provide aliases for supported request methods utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) { return this.request(utils.merge(config || {}, { method: method, url: url })); }; }); utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) { return this.request(utils.merge(config || {}, { method: method, url: url, data: data })); }; }); module.exports = Axios; /***/ }, /* 9 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); var normalizeHeaderName = __webpack_require__(10); var DEFAULT_CONTENT_TYPE = { 'Content-Type': 'application/x-www-form-urlencoded' }; function setContentTypeIfUnset(headers, value) { if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) { headers['Content-Type'] = value; } } function getDefaultAdapter() { var adapter; if (typeof XMLHttpRequest !== 'undefined') { // For browsers use XHR adapter adapter = __webpack_require__(11); } else if (typeof process !== 'undefined') { // For node use HTTP adapter adapter = __webpack_require__(11); } return adapter; } var defaults = { adapter: getDefaultAdapter(), transformRequest: [function transformRequest(data, headers) { normalizeHeaderName(headers, 'Content-Type'); if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data) ) { return data; } if (utils.isArrayBufferView(data)) { return data.buffer; } if (utils.isURLSearchParams(data)) { setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'); return data.toString(); } if (utils.isObject(data)) { setContentTypeIfUnset(headers, 'application/json;charset=utf-8'); return JSON.stringify(data); } return data; }], transformResponse: [function transformResponse(data) { /*eslint no-param-reassign:0*/ if (typeof data === 'string') { try { data = JSON.parse(data); } catch (e) { /* Ignore */ } } return data; }], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, validateStatus: function validateStatus(status) { return status >= 200 && status < 300; } }; defaults.headers = { common: { 'Accept': 'application/json, text/plain, */*' } }; utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) { defaults.headers[method] = {}; }); utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE); }); module.exports = defaults; /***/ }, /* 10 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); module.exports = function normalizeHeaderName(headers, normalizedName) { utils.forEach(headers, function processHeader(value, name) { if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) { headers[normalizedName] = value; delete headers[name]; } }); }; /***/ }, /* 11 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); var settle = __webpack_require__(12); var buildURL = __webpack_require__(15); var parseHeaders = __webpack_require__(16); var isURLSameOrigin = __webpack_require__(17); var createError = __webpack_require__(13); var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(18); module.exports = function xhrAdapter(config) { return new Promise(function dispatchXhrRequest(resolve, reject) { var requestData = config.data; var requestHeaders = config.headers; if (utils.isFormData(requestData)) { delete requestHeaders['Content-Type']; // Let the browser set it } var request = new XMLHttpRequest(); var loadEvent = 'onreadystatechange'; var xDomain = false; // For IE 8/9 CORS support // Only supports POST and GET calls and doesn't returns the response headers. // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest. if (("production") !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) { request = new window.XDomainRequest(); loadEvent = 'onload'; xDomain = true; request.onprogress = function handleProgress() {}; request.ontimeout = function handleTimeout() {}; } // HTTP basic authentication if (config.auth) { var username = config.auth.username || ''; var password = config.auth.password || ''; requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password); } request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS request.timeout = config.timeout; // Listen for ready state request[loadEvent] = function handleLoad() { if (!request || (request.readyState !== 4 && !xDomain)) { return; } // The request errored out and we didn't get a response, this will be // handled by onerror instead // With one exception: request that using file: protocol, most browsers // will return status as 0 even though it's a successful request if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) { return; } // Prepare the response var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null; var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response; var response = { data: responseData, // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201) status: request.status === 1223 ? 204 : request.status, statusText: request.status === 1223 ? 'No Content' : request.statusText, headers: responseHeaders, config: config, request: request }; settle(resolve, reject, response); // Clean up request request = null; }; // Handle low level network errors request.onerror = function handleError() { // Real errors are hidden from us by the browser // onerror should only fire if it's a network error reject(createError('Network Error', config)); // Clean up request request = null; }; // Handle timeout request.ontimeout = function handleTimeout() { reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED')); // Clean up request request = null; }; // Add xsrf header // This is only done if running in a standard browser environment. // Specifically not if we're in a web worker, or react-native. if (utils.isStandardBrowserEnv()) { var cookies = __webpack_require__(19); // Add xsrf header var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined; if (xsrfValue) { requestHeaders[config.xsrfHeaderName] = xsrfValue; } } // Add headers to the request if ('setRequestHeader' in request) { utils.forEach(requestHeaders, function setRequestHeader(val, key) { if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') { // Remove Content-Type if data is undefined delete requestHeaders[key]; } else { // Otherwise add header to the request request.setRequestHeader(key, val); } }); } // Add withCredentials to request if needed if (config.withCredentials) { request.withCredentials = true; } // Add responseType to request if needed if (config.responseType) { try { request.responseType = config.responseType; } catch (e) { // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2. // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function. if (config.responseType !== 'json') { throw e; } } } // Handle progress if needed if (typeof config.onDownloadProgress === 'function') { request.addEventListener('progress', config.onDownloadProgress); } // Not all browsers support upload events if (typeof config.onUploadProgress === 'function' && request.upload) { request.upload.addEventListener('progress', config.onUploadProgress); } if (config.cancelToken) { // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) { if (!request) { return; } request.abort(); reject(cancel); // Clean up request request = null; }); } if (requestData === undefined) { requestData = null; } // Send the request request.send(requestData); }); }; /***/ }, /* 12 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var createError = __webpack_require__(13); /** * Resolve or reject a Promise based on response status. * * @param {Function} resolve A function that resolves the promise. * @param {Function} reject A function that rejects the promise. * @param {object} response The response. */ module.exports = function settle(resolve, reject, response) { var validateStatus = response.config.validateStatus; // Note: status is not exposed by XDomainRequest if (!response.status || !validateStatus || validateStatus(response.status)) { resolve(response); } else { reject(createError( 'Request failed with status code ' + response.status, response.config, null, response )); } }; /***/ }, /* 13 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var enhanceError = __webpack_require__(14); /** * Create an Error with the specified message, config, error code, and response. * * @param {string} message The error message. * @param {Object} config The config. * @param {string} [code] The error code (for example, 'ECONNABORTED'). @ @param {Object} [response] The response. * @returns {Error} The created error. */ module.exports = function createError(message, config, code, response) { var error = new Error(message); return enhanceError(error, config, code, response); }; /***/ }, /* 14 */ /***/ function(module, exports) { 'use strict'; /** * Update an Error with the specified config, error code, and response. * * @param {Error} error The error to update. * @param {Object} config The config. * @param {string} [code] The error code (for example, 'ECONNABORTED'). @ @param {Object} [response] The response. * @returns {Error} The error. */ module.exports = function enhanceError(error, config, code, response) { error.config = config; if (code) { error.code = code; } error.response = response; return error; }; /***/ }, /* 15 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); function encode(val) { return encodeURIComponent(val). replace(/%40/gi, '@'). replace(/%3A/gi, ':'). replace(/%24/g, '$'). replace(/%2C/gi, ','). replace(/%20/g, '+'). replace(/%5B/gi, '['). replace(/%5D/gi, ']'); } /** * Build a URL by appending params to the end * * @param {string} url The base of the url (e.g., http://www.google.com) * @param {object} [params] The params to be appended * @returns {string} The formatted url */ module.exports = function buildURL(url, params, paramsSerializer) { /*eslint no-param-reassign:0*/ if (!params) { return url; } var serializedParams; if (paramsSerializer) { serializedParams = paramsSerializer(params); } else if (utils.isURLSearchParams(params)) { serializedParams = params.toString(); } else { var parts = []; utils.forEach(params, function serialize(val, key) { if (val === null || typeof val === 'undefined') { return; } if (utils.isArray(val)) { key = key + '[]'; } if (!utils.isArray(val)) { val = [val]; } utils.forEach(val, function parseValue(v) { if (utils.isDate(v)) { v = v.toISOString(); } else if (utils.isObject(v)) { v = JSON.stringify(v); } parts.push(encode(key) + '=' + encode(v)); }); }); serializedParams = parts.join('&'); } if (serializedParams) { url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams; } return url; }; /***/ }, /* 16 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); /** * Parse headers into an object * * ``` * Date: Wed, 27 Aug 2014 08:58:49 GMT * Content-Type: application/json * Connection: keep-alive * Transfer-Encoding: chunked * ``` * * @param {String} headers Headers needing to be parsed * @returns {Object} Headers parsed into an object */ module.exports = function parseHeaders(headers) { var parsed = {}; var key; var val; var i; if (!headers) { return parsed; } utils.forEach(headers.split('\n'), function parser(line) { i = line.indexOf(':'); key = utils.trim(line.substr(0, i)).toLowerCase(); val = utils.trim(line.substr(i + 1)); if (key) { parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val; } }); return parsed; }; /***/ }, /* 17 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); module.exports = ( utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test // whether the request URL is of the same origin as current location. (function standardBrowserEnv() { var msie = /(msie|trident)/i.test(navigator.userAgent); var urlParsingNode = document.createElement('a'); var originURL; /** * Parse a URL to discover it's components * * @param {String} url The URL to be parsed * @returns {Object} */ function resolveURL(url) { var href = url; if (msie) { // IE needs attribute set twice to normalize properties urlParsingNode.setAttribute('href', href); href = urlParsingNode.href; } urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils return { href: urlParsingNode.href, protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '', host: urlParsingNode.host, search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '', hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '', hostname: urlParsingNode.hostname, port: urlParsingNode.port, pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname }; } originURL = resolveURL(window.location.href); /** * Determine if a URL shares the same origin as the current location * * @param {String} requestURL The URL to test * @returns {boolean} True if URL shares the same origin, otherwise false */ return function isURLSameOrigin(requestURL) { var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL; return (parsed.protocol === originURL.protocol && parsed.host === originURL.host); }; })() : // Non standard browser envs (web workers, react-native) lack needed support. (function nonStandardBrowserEnv() { return function isURLSameOrigin() { return true; }; })() ); /***/ }, /* 18 */ /***/ function(module, exports) { 'use strict'; // btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; function E() { this.message = 'String contains an invalid character'; } E.prototype = new Error; E.prototype.code = 5; E.prototype.name = 'InvalidCharacterError'; function btoa(input) { var str = String(input); var output = ''; for ( // initialize result and counter var block, charCode, idx = 0, map = chars; // if the next str index does not exist: // change the mapping table to "=" // check if d has no fractional digits str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8 output += map.charAt(63 & block >> 8 - idx % 1 * 8) ) { charCode = str.charCodeAt(idx += 3 / 4); if (charCode > 0xFF) { throw new E(); } block = block << 8 | charCode; } return output; } module.exports = btoa; /***/ }, /* 19 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); module.exports = ( utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie (function standardBrowserEnv() { return { write: function write(name, value, expires, path, domain, secure) { var cookie = []; cookie.push(name + '=' + encodeURIComponent(value)); if (utils.isNumber(expires)) { cookie.push('expires=' + new Date(expires).toGMTString()); } if (utils.isString(path)) { cookie.push('path=' + path); } if (utils.isString(domain)) { cookie.push('domain=' + domain); } if (secure === true) { cookie.push('secure'); } document.cookie = cookie.join('; '); }, read: function read(name) { var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)')); return (match ? decodeURIComponent(match[3]) : null); }, remove: function remove(name) { this.write(name, '', Date.now() - 86400000); } }; })() : // Non standard browser env (web workers, react-native) lack needed support. (function nonStandardBrowserEnv() { return { write: function write() {}, read: function read() { return null; }, remove: function remove() {} }; })() ); /***/ }, /* 20 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); function InterceptorManager() { this.handlers = []; } /** * Add a new interceptor to the stack * * @param {Function} fulfilled The function to handle `then` for a `Promise` * @param {Function} rejected The function to handle `reject` for a `Promise` * * @return {Number} An ID used to remove interceptor later */ InterceptorManager.prototype.use = function use(fulfilled, rejected) { this.handlers.push({ fulfilled: fulfilled, rejected: rejected }); return this.handlers.length - 1; }; /** * Remove an interceptor from the stack * * @param {Number} id The ID that was returned by `use` */ InterceptorManager.prototype.eject = function eject(id) { if (this.handlers[id]) { this.handlers[id] = null; } }; /** * Iterate over all the registered interceptors * * This method is particularly useful for skipping over any * interceptors that may have become `null` calling `eject`. * * @param {Function} fn The function to call for each interceptor */ InterceptorManager.prototype.forEach = function forEach(fn) { utils.forEach(this.handlers, function forEachHandler(h) { if (h !== null) { fn(h); } }); }; module.exports = InterceptorManager; /***/ }, /* 21 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); var transformData = __webpack_require__(22); var isCancel = __webpack_require__(23); var defaults = __webpack_require__(9); /** * Throws a `Cancel` if cancellation has been requested. */ function throwIfCancellationRequested(config) { if (config.cancelToken) { config.cancelToken.throwIfRequested(); } } /** * Dispatch a request to the server using the configured adapter. * * @param {object} config The config that is to be used for the request * @returns {Promise} The Promise to be fulfilled */ module.exports = function dispatchRequest(config) { throwIfCancellationRequested(config); // Ensure headers exist config.headers = config.headers || {}; // Transform request data config.data = transformData( config.data, config.headers, config.transformRequest ); // Flatten headers config.headers = utils.merge( config.headers.common || {}, config.headers[config.method] || {}, config.headers || {} ); utils.forEach( ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) { delete config.headers[method]; } ); var adapter = config.adapter || defaults.adapter; return adapter(config).then(function onAdapterResolution(response) { throwIfCancellationRequested(config); // Transform response data response.data = transformData( response.data, response.headers, config.transformResponse ); return response; }, function onAdapterRejection(reason) { if (!isCancel(reason)) { throwIfCancellationRequested(config); // Transform response data if (reason && reason.response) { reason.response.data = transformData( reason.response.data, reason.response.headers, config.transformResponse ); } } return Promise.reject(reason); }); }; /***/ }, /* 22 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var utils = __webpack_require__(2); /** * Transform the data for a request or a response * * @param {Object|String} data The data to be transformed * @param {Array} headers The headers for the request or response * @param {Array|Function} fns A single function or Array of functions * @returns {*} The resulting transformed data */ module.exports = function transformData(data, headers, fns) { /*eslint no-param-reassign:0*/ utils.forEach(fns, function transform(fn) { data = fn(data, headers); }); return data; }; /***/ }, /* 23 */ /***/ function(module, exports) { 'use strict'; module.exports = function isCancel(value) { return !!(value && value.__CANCEL__); }; /***/ }, /* 24 */ /***/ function(module, exports) { 'use strict'; /** * Determines whether the specified URL is absolute * * @param {string} url The URL to test * @returns {boolean} True if the specified URL is absolute, otherwise false */ module.exports = function isAbsoluteURL(url) { // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL). // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed // by any combination of letters, digits, plus, period, or hyphen. return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url); }; /***/ }, /* 25 */ /***/ function(module, exports) { 'use strict'; /** * Creates a new URL by combining the specified URLs * * @param {string} baseURL The base URL * @param {string} relativeURL The relative URL * @returns {string} The combined URL */ module.exports = function combineURLs(baseURL, relativeURL) { return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL; }; /***/ }, /* 26 */ /***/ function(module, exports) { 'use strict'; /** * A `Cancel` is an object that is thrown when an operation is canceled. * * @class * @param {string=} message The message. */ function Cancel(message) { this.message = message; } Cancel.prototype.toString = function toString() { return 'Cancel' + (this.message ? ': ' + this.message : ''); }; Cancel.prototype.__CANCEL__ = true; module.exports = Cancel; /***/ }, /* 27 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; var Cancel = __webpack_require__(26); /** * A `CancelToken` is an object that can be used to request cancellation of an operation. * * @class * @param {Function} executor The executor function. */ function CancelToken(executor) { if (typeof executor !== 'function') { throw new TypeError('executor must be a function.'); } var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) { resolvePromise = resolve; }); var token = this; executor(function cancel(message) { if (token.reason) { // Cancellation has already been requested return; } token.reason = new Cancel(message); resolvePromise(token.reason); }); } /** * Throws a `Cancel` if cancellation has been requested. */ CancelToken.prototype.throwIfRequested = function throwIfRequested() { if (this.reason) { throw this.reason; } }; /** * Returns an object that contains a new `CancelToken` and a function that, when called, * cancels the `CancelToken`. */ CancelToken.source = function source() { var cancel; var token = new CancelToken(function executor(c) { cancel = c; }); return { token: token, cancel: cancel }; }; module.exports = CancelToken; /***/ }, /* 28 */ /***/ function(module, exports) { 'use strict'; /** * Syntactic sugar for invoking a function and expanding an array for arguments. * * Common use case would be to use `Function.prototype.apply`. * * ```js * function f(x, y, z) {} * var args = [1, 2, 3]; * f.apply(null, args); * ``` * * With `spread` this example can be re-written. * * ```js * spread(function(x, y, z) {})([1, 2, 3]); * ``` * * @param {Function} callback * @returns {Function} */ module.exports = function spread(callback) { return function wrap(arr) { return callback.apply(null, arr); }; }; /***/ } /******/ ]) }); ; // WEBPACK FOOTER // // axios.min.js",
" // The module cache var installedModules = {}; // The require function function __webpack_require__(moduleId) { // Check if module is in cache if(installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = { exports: {}, id: moduleId, loaded: false }; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.loaded = true; // Return the exports of the module return module.exports; } // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // __webpack_public_path__ __webpack_require__.p = ""; // Load entry module and return exports return __webpack_require__(0); // WEBPACK FOOTER // // webpack/bootstrap 6f5fdb0af744004f46bc",
"module.exports = require('./lib/axios'); ////////////////// // WEBPACK FOOTER // ./index.js // module id = 0 // module chunks = 0",
"'use strict'; var utils = require('./utils'); var bind = require('./helpers/bind'); var Axios = require('./core/Axios'); var defaults = require('./defaults'); /** * Create an instance of Axios * * @param {Object} defaultConfig The default config for the instance * @return {Axios} A new instance of Axios */ function createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance utils.extend(instance, Axios.prototype, context); // Copy context to instance utils.extend(instance, context); return instance; } // Create the default instance to be exported var axios = createInstance(defaults); // Expose Axios class to allow class inheritance axios.Axios = Axios; // Factory for creating new instances axios.create = function create(instanceConfig) { return createInstance(utils.merge(defaults, instanceConfig)); }; // Expose Cancel & CancelToken axios.Cancel = require('./cancel/Cancel'); axios.CancelToken = require('./cancel/CancelToken'); axios.isCancel = require('./cancel/isCancel'); // Expose all/spread axios.all = function all(promises) { return Promise.all(promises); }; axios.spread = require('./helpers/spread'); module.exports = axios; // Allow use of default import syntax in TypeScript module.exports.default = axios; ////////////////// // WEBPACK FOOTER // ./lib/axios.js // module id = 1 // module chunks = 0",
"'use strict'; var bind = require('./helpers/bind'); /*global toString:true*/ // utils is a library of generic helper functions non-specific to axios var toString = Object.prototype.toString; /** * Determine if a value is an Array * * @param {Object} val The value to test * @returns {boolean} True if value is an Array, otherwise false */ function isArray(val) { return toString.call(val) === '[object Array]'; } /** * Determine if a value is a Node Buffer * * @param {Object} val The value to test * @returns {boolean} True if value is a Node Buffer, otherwise false */ function isBuffer(val) { return ((typeof Buffer !== 'undefined') && (Buffer.isBuffer) && (Buffer.isBuffer(val))); } /** * Determine if a value is an ArrayBuffer * * @param {Object} val The value to test * @returns {boolean} True if value is an ArrayBuffer, otherwise false */ function isArrayBuffer(val) { return toString.call(val) === '[object ArrayBuffer]'; } /** * Determine if a value is a FormData * * @param {Object} val The value to test * @returns {boolean} True if value is an FormData, otherwise false */ function isFormData(val) { return (typeof FormData !== 'undefined') && (val instanceof FormData); } /** * Determine if a value is a view on an ArrayBuffer * * @param {Object} val The value to test * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false */ function isArrayBufferView(val) { var result; if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) { result = ArrayBuffer.isView(val); } else { result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer); } return result; } /** * Determine if a value is a String * * @param {Object} val The value to test * @returns {boolean} True if value is a String, otherwise false */ function isString(val) { return typeof val === 'string'; } /** * Determine if a value is a Number * * @param {Object} val The value to test * @returns {boolean} True if value is a Number, otherwise false */ function isNumber(val) { return typeof val === 'number'; } /** * Determine if a value is undefined * * @param {Object} val The value to test * @returns {boolean} True if the value is undefined, otherwise false */ function isUndefined(val) { return typeof val === 'undefined'; } /** * Determine if a value is an Object * * @param {Object} val The value to test * @returns {boolean} True if value is an Object, otherwise false */ function isObject(val) { return val !== null && typeof val === 'object'; } /** * Determine if a value is a Date * * @param {Object} val The value to test * @returns {boolean} True if value is a Date, otherwise false */ function isDate(val) { return toString.call(val) === '[object Date]'; } /** * Determine if a value is a File * * @param {Object} val The value to test * @returns {boolean} True if value is a File, otherwise false */ function isFile(val) { return toString.call(val) === '[object File]'; } /** * Determine if a value is a Blob * * @param {Object} val The value to test * @returns {boolean} True if value is a Blob, otherwise false */ function isBlob(val) { return toString.call(val) === '[object Blob]'; } /** * Determine if a value is a Function * * @param {Object} val The value to test * @returns {boolean} True if value is a Function, otherwise false */ function isFunction(val) { return toString.call(val) === '[object Function]'; } /** * Determine if a value is a Stream * * @param {Object} val The value to test * @returns {boolean} True if value is a Stream, otherwise false */ function isStream(val) { return isObject(val) && isFunction(val.pipe); } /** * Determine if a value is a URLSearchParams object * * @param {Object} val The value to test * @returns {boolean} True if value is a URLSearchParams object, otherwise false */ function isURLSearchParams(val) { return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams; } /** * Trim excess whitespace off the beginning and end of a string * * @param {String} str The String to trim * @returns {String} The String freed of excess whitespace */ function trim(str) { return str.replace(/^\s*/, '').replace(/\s*$/, ''); } /** * Determine if we're running in a standard browser environment * * This allows axios to run in a web worker, and react-native. * Both environments support XMLHttpRequest, but not fully standard globals. * * web workers: * typeof window -> undefined * typeof document -> undefined * * react-native: * navigator.product -> 'ReactNative' */ function isStandardBrowserEnv() { if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') { return false; } return ( typeof window !== 'undefined' && typeof document !== 'undefined' ); } /** * Iterate over an Array or an Object invoking a function for each item. * * If `obj` is an Array callback will be called passing * the value, index, and complete array for each item. * * If 'obj' is an Object callback will be called passing * the value, key, and complete object for each property. * * @param {Object|Array} obj The object to iterate * @param {Function} fn The callback to invoke for each item */ function forEach(obj, fn) { // Don't bother if no value provided if (obj === null || typeof obj === 'undefined') { return; } // Force an array if not already something iterable if (typeof obj !== 'object' && !isArray(obj)) { /*eslint no-param-reassign:0*/ obj = [obj]; } if (isArray(obj)) { // Iterate over array values for (var i = 0, l = obj.length; i < l; i++) { fn.call(null, obj[i], i, obj); } } else { // Iterate over object keys for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { fn.call(null, obj[key], key, obj); } } } } /** * Accepts varargs expecting each argument to be an object, then * immutably merges the properties of each object and returns result. * * When multiple objects contain the same key the later object in * the arguments list will take precedence. * * Example: * * ```js * var result = merge({foo: 123}, {foo: 456}); * console.log(result.foo); // outputs 456 * ``` * * @param {Object} obj1 Object to merge * @returns {Object} Result of all merge properties */ function merge(/* obj1, obj2, obj3, ... */) { var result = {}; function assignValue(val, key) { if (typeof result[key] === 'object' && typeof val === 'object') { result[key] = merge(result[key], val); } else { result[key] = val; } } for (var i = 0, l = arguments.length; i < l; i++) { forEach(arguments[i], assignValue); } return result; } /** * Extends object a by mutably adding to it the properties of object b. * * @param {Object} a The object to be extended * @param {Object} b The object to copy properties from * @param {Object} thisArg The object to bind function to * @return {Object} The resulting value of object a */ function extend(a, b, thisArg) { forEach(b, function assignValue(val, key) { if (thisArg && typeof val === 'function') { a[key] = bind(val, thisArg); } else { a[key] = val; } }); return a; } module.exports = { isArray: isArray, isArrayBuffer: isArrayBuffer, isBuffer: isBuffer, isFormData: isFormData, isArrayBufferView: isArrayBufferView, isString: isString, isNumber: isNumber, isObject: isObject, isUndefined: isUndefined, isDate: isDate, isFile: isFile, isBlob: isBlob, isFunction: isFunction, isStream: isStream, isURLSearchParams: isURLSearchParams, isStandardBrowserEnv: isStandardBrowserEnv, forEach: forEach, merge: merge, extend: extend, trim: trim }; ////////////////// // WEBPACK FOOTER // ./lib/utils.js // module id = 2 // module chunks = 0",
"/*! * The buffer module from node.js, for the browser. * * @author Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license MIT */ /* eslint-disable no-proto */ 'use strict' var base64 = require('base64-js') var ieee754 = require('ieee754') var isArray = require('isarray') exports.Buffer = Buffer exports.SlowBuffer = SlowBuffer exports.INSPECT_MAX_BYTES = 50 /** * If `Buffer.TYPED_ARRAY_SUPPORT`: * === true Use Uint8Array implementation (fastest) * === false Use Object implementation (most compatible, even IE6) * * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+, * Opera 11.6+, iOS 4.2+. * * Due to various browser bugs, sometimes the Object implementation will be used even * when the browser supports typed arrays. * * Note: * * - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances, * See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438. * * - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function. * * - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of * incorrect length in some situations. * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they * get the Object implementation, which is slower but behaves correctly. */ Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport() /* * Export kMaxLength after typed array support is determined. */ exports.kMaxLength = kMaxLength() function typedArraySupport () { try { var arr = new Uint8Array(1) arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }} return arr.foo() === 42 && // typed array instances can be augmented typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray` arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray` } catch (e) { return false } } function kMaxLength () { return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff } function createBuffer (that, length) { if (kMaxLength() < length) { throw new RangeError('Invalid typed array length') } if (Buffer.TYPED_ARRAY_SUPPORT) { // Return an augmented `Uint8Array` instance, for best performance that = new Uint8Array(length) that.__proto__ = Buffer.prototype } else { // Fallback: Return an object instance of the Buffer class if (that === null) { that = new Buffer(length) } that.length = length } return that } /** * The Buffer constructor returns instances of `Uint8Array` that have their * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of * `Uint8Array`, so the returned instances will have all the node `Buffer` methods * and the `Uint8Array` methods. Square bracket notation works as expected -- it * returns a single octet. * * The `Uint8Array` prototype remains unmodified. */ function Buffer (arg, encodingOrOffset, length) { if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) { return new Buffer(arg, encodingOrOffset, length) } // Common case. if (typeof arg === 'number') { if (typeof encodingOrOffset === 'string') { throw new Error( 'If encoding is specified then the first argument must be a string' ) } return allocUnsafe(this, arg) } return from(this, arg, encodingOrOffset, length) } Buffer.poolSize = 8192 // not used by this implementation // TODO: Legacy, not needed anymore. Remove in next major version. Buffer._augment = function (arr) { arr.__proto__ = Buffer.prototype return arr } function from (that, value, encodingOrOffset, length) { if (typeof value === 'number') { throw new TypeError('"value" argument must not be a number') } if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) { return fromArrayBuffer(that, value, encodingOrOffset, length) } if (typeof value === 'string') { return fromString(that, value, encodingOrOffset) } return fromObject(that, value) } /** * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError * if value is a number. * Buffer.from(str[, encoding]) * Buffer.from(array) * Buffer.from(buffer) * Buffer.from(arrayBuffer[, byteOffset[, length]]) **/ Buffer.from = function (value, encodingOrOffset, length) { return from(null, value, encodingOrOffset, length) } if (Buffer.TYPED_ARRAY_SUPPORT) { Buffer.prototype.__proto__ = Uint8Array.prototype Buffer.__proto__ = Uint8Array if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) { // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97 Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: true }) } } function assertSize (size) { if (typeof size !== 'number') { throw new TypeError('"size" argument must be a number') } else if (size < 0) { throw new RangeError('"size" argument must not be negative') } } function alloc (that, size, fill, encoding) { assertSize(size) if (size <= 0) { return createBuffer(that, size) } if (fill !== undefined) { // Only pay attention to encoding if it's a string. This // prevents accidentally sending in a number that would // be interpretted as a start offset. return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill) } return createBuffer(that, size) } /** * Creates a new filled Buffer instance. * alloc(size[, fill[, encoding]]) **/ Buffer.alloc = function (size, fill, encoding) { return alloc(null, size, fill, encoding) } function allocUnsafe (that, size) { assertSize(size) that = createBuffer(that, size < 0 ? 0 : checked(size) | 0) if (!Buffer.TYPED_ARRAY_SUPPORT) { for (var i = 0; i < size; ++i) { that[i] = 0 } } return that } /** * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance. * */ Buffer.allocUnsafe = function (size) { return allocUnsafe(null, size) } /** * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance. */ Buffer.allocUnsafeSlow = function (size) { return allocUnsafe(null, size) } function fromString (that, string, encoding) { if (typeof encoding !== 'string' || encoding === '') { encoding = 'utf8' } if (!Buffer.isEncoding(encoding)) { throw new TypeError('"encoding" must be a valid string encoding') } var length = byteLength(string, encoding) | 0 that = createBuffer(that, length) var actual = that.write(string, encoding) if (actual !== length) { // Writing a hex string, for example, that contains invalid characters will // cause everything after the first invalid character to be ignored. (e.g. // 'abxxcd' will be treated as 'ab') that = that.slice(0, actual) } return that } function fromArrayLike (that, array) { var length = array.length < 0 ? 0 : checked(array.length) | 0 that = createBuffer(that, length) for (var i = 0; i < length; i += 1) { that[i] = array[i] & 255 } return that } function fromArrayBuffer (that, array, byteOffset, length) { array.byteLength // this throws if `array` is not a valid ArrayBuffer if (byteOffset < 0 || array.byteLength < byteOffset) { throw new RangeError('\'offset\' is out of bounds') } if (array.byteLength < byteOffset + (length || 0)) { throw new RangeError('\'length\' is out of bounds') } if (byteOffset === undefined && length === undefined) { array = new Uint8Array(array) } else if (length === undefined) { array = new Uint8Array(array, byteOffset) } else { array = new Uint8Array(array, byteOffset, length) } if (Buffer.TYPED_ARRAY_SUPPORT) { // Return an augmented `Uint8Array` instance, for best performance that = array that.__proto__ = Buffer.prototype } else { // Fallback: Return an object instance of the Buffer class that = fromArrayLike(that, array) } return that } function fromObject (that, obj) { if (Buffer.isBuffer(obj)) { var len = checked(obj.length) | 0 that = createBuffer(that, len) if (that.length === 0) { return that } obj.copy(that, 0, 0, len) return that } if (obj) { if ((typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer) || 'length' in obj) { if (typeof obj.length !== 'number' || isnan(obj.length)) { return createBuffer(that, 0) } return fromArrayLike(that, obj) } if (obj.type === 'Buffer' && isArray(obj.data)) { return fromArrayLike(that, obj.data) } } throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.') } function checked (length) { // Note: cannot use `length < kMaxLength()` here because that fails when // length is NaN (which is otherwise coerced to zero.) if (length >= kMaxLength()) { throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes') } return length | 0 } function SlowBuffer (length) { if (+length != length) { // eslint-disable-line eqeqeq length = 0 } return Buffer.alloc(+length) } Buffer.isBuffer = function isBuffer (b) { return !!(b != null && b._isBuffer) } Buffer.compare = function compare (a, b) { if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) { throw new TypeError('Arguments must be Buffers') } if (a === b) return 0 var x = a.length var y = b.length for (var i = 0, len = Math.min(x, y); i < len; ++i) { if (a[i] !== b[i]) { x = a[i] y = b[i] break } } if (x < y) return -1 if (y < x) return 1 return 0 } Buffer.isEncoding = function isEncoding (encoding) { switch (String(encoding).toLowerCase()) { case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'latin1': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return true default: return false } } Buffer.concat = function concat (list, length) { if (!isArray(list)) { throw new TypeError('"list" argument must be an Array of Buffers') } if (list.length === 0) { return Buffer.alloc(0) } var i if (length === undefined) { length = 0 for (i = 0; i < list.length; ++i) { length += list[i].length } } var buffer = Buffer.allocUnsafe(length) var pos = 0 for (i = 0; i < list.length; ++i) { var buf = list[i] if (!Buffer.isBuffer(buf)) { throw new TypeError('"list" argument must be an Array of Buffers') } buf.copy(buffer, pos) pos += buf.length } return buffer } function byteLength (string, encoding) { if (Buffer.isBuffer(string)) { return string.length } if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) { return string.byteLength } if (typeof string !== 'string') { string = '' + string } var len = string.length if (len === 0) return 0 // Use a for loop to avoid recursion var loweredCase = false for (;;) { switch (encoding) { case 'ascii': case 'latin1': case 'binary': return len case 'utf8': case 'utf-8': case undefined: return utf8ToBytes(string).length case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return len * 2 case 'hex': return len >>> 1 case 'base64': return base64ToBytes(string).length default: if (loweredCase) return utf8ToBytes(string).length // assume utf8 encoding = ('' + encoding).toLowerCase() loweredCase = true } } } Buffer.byteLength = byteLength function slowToString (encoding, start, end) { var loweredCase = false // No need to verify that "this.length <= MAX_UINT32" since it's a read-only // property of a typed array. // This behaves neither like String nor Uint8Array in that we set start/end // to their upper/lower bounds if the value passed is out of range. // undefined is handled specially as per ECMA-262 6th Edition, // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization. if (start === undefined || start < 0) { start = 0 } // Return early if start > this.length. Done here to prevent potential uint32 // coercion fail below. if (start > this.length) { return '' } if (end === undefined || end > this.length) { end = this.length } if (end <= 0) { return '' } // Force coersion to uint32. This will also coerce falsey/NaN values to 0. end >>>= 0 start >>>= 0 if (end <= start) { return '' } if (!encoding) encoding = 'utf8' while (true) { switch (encoding) { case 'hex': return hexSlice(this, start, end) case 'utf8': case 'utf-8': return utf8Slice(this, start, end) case 'ascii': return asciiSlice(this, start, end) case 'latin1': case 'binary': return latin1Slice(this, start, end) case 'base64': return base64Slice(this, start, end) case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return utf16leSlice(this, start, end) default: if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding) encoding = (encoding + '').toLowerCase() loweredCase = true } } } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect // Buffer instances. Buffer.prototype._isBuffer = true function swap (b, n, m) { var i = b[n] b[n] = b[m] b[m] = i } Buffer.prototype.swap16 = function swap16 () { var len = this.length if (len % 2 !== 0) { throw new RangeError('Buffer size must be a multiple of 16-bits') } for (var i = 0; i < len; i += 2) { swap(this, i, i + 1) } return this } Buffer.prototype.swap32 = function swap32 () { var len = this.length if (len % 4 !== 0) { throw new RangeError('Buffer size must be a multiple of 32-bits') } for (var i = 0; i < len; i += 4) { swap(this, i, i + 3) swap(this, i + 1, i + 2) } return this } Buffer.prototype.swap64 = function swap64 () { var len = this.length if (len % 8 !== 0) { throw new RangeError('Buffer size must be a multiple of 64-bits') } for (var i = 0; i < len; i += 8) { swap(this, i, i + 7) swap(this, i + 1, i + 6) swap(this, i + 2, i + 5) swap(this, i + 3, i + 4) } return this } Buffer.prototype.toString = function toString () { var length = this.length | 0 if (length === 0) return '' if (arguments.length === 0) return utf8Slice(this, 0, length) return slowToString.apply(this, arguments) } Buffer.prototype.equals = function equals (b) { if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer') if (this === b) return true return Buffer.compare(this, b) === 0 } Buffer.prototype.inspect = function inspect () { var str = '' var max = exports.INSPECT_MAX_BYTES if (this.length > 0) { str = this.toString('hex', 0, max).match(/.{2}/g).join(' ') if (this.length > max) str += ' ... ' } return '<Buffer ' + str + '>' } Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) { if (!Buffer.isBuffer(target)) { throw new TypeError('Argument must be a Buffer') } if (start === undefined) { start = 0 } if (end === undefined) { end = target ? target.length : 0 } if (thisStart === undefined) { thisStart = 0 } if (thisEnd === undefined) { thisEnd = this.length } if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) { throw new RangeError('out of range index') } if (thisStart >= thisEnd && start >= end) { return 0 } if (thisStart >= thisEnd) { return -1 } if (start >= end) { return 1 } start >>>= 0 end >>>= 0 thisStart >>>= 0 thisEnd >>>= 0 if (this === target) return 0 var x = thisEnd - thisStart var y = end - start var len = Math.min(x, y) var thisCopy = this.slice(thisStart, thisEnd) var targetCopy = target.slice(start, end) for (var i = 0; i < len; ++i) { if (thisCopy[i] !== targetCopy[i]) { x = thisCopy[i] y = targetCopy[i] break } } if (x < y) return -1 if (y < x) return 1 return 0 } // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`, // OR the last index of `val` in `buffer` at offset <= `byteOffset`. // // Arguments: // - buffer - a Buffer to search // - val - a string, Buffer, or number // - byteOffset - an index into `buffer`; will be clamped to an int32 // - encoding - an optional encoding, relevant is val is a string // - dir - true for indexOf, false for lastIndexOf function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) { // Empty buffer means no match if (buffer.length === 0) return -1 // Normalize byteOffset if (typeof byteOffset === 'string') { encoding = byteOffset byteOffset = 0 } else if (byteOffset > 0x7fffffff) { byteOffset = 0x7fffffff } else if (byteOffset < -0x80000000) { byteOffset = -0x80000000 } byteOffset = +byteOffset // Coerce to Number. if (isNaN(byteOffset)) { // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer byteOffset = dir ? 0 : (buffer.length - 1) } // Normalize byteOffset: negative offsets start from the end of the buffer if (byteOffset < 0) byteOffset = buffer.length + byteOffset if (byteOffset >= buffer.length) { if (dir) return -1 else byteOffset = buffer.length - 1 } else if (byteOffset < 0) { if (dir) byteOffset = 0 else return -1 } // Normalize val if (typeof val === 'string') { val = Buffer.from(val, encoding) } // Finally, search either indexOf (if dir is true) or lastIndexOf if (Buffer.isBuffer(val)) { // Special case: looking for empty string/buffer always fails if (val.length === 0) { return -1 } return arrayIndexOf(buffer, val, byteOffset, encoding, dir) } else if (typeof val === 'number') { val = val & 0xFF // Search for a byte value [0-255] if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') { if (dir) { return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) } else { return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) } } return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir) } throw new TypeError('val must be string, number or Buffer') } function arrayIndexOf (arr, val, byteOffset, encoding, dir) { var indexSize = 1 var arrLength = arr.length var valLength = val.length if (encoding !== undefined) { encoding = String(encoding).toLowerCase() if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') { if (arr.length < 2 || val.length < 2) { return -1 } indexSize = 2 arrLength /= 2 valLength /= 2 byteOffset /= 2 } } function read (buf, i) { if (indexSize === 1) { return buf[i] } else { return buf.readUInt16BE(i * indexSize) } } var i if (dir) { var foundIndex = -1 for (i = byteOffset; i < arrLength; i++) { if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) { if (foundIndex === -1) foundIndex = i if (i - foundIndex + 1 === valLength) return foundIndex * indexSize } else { if (foundIndex !== -1) i -= i - foundIndex foundIndex = -1 } } } else { if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength for (i = byteOffset; i >= 0; i--) { var found = true for (var j = 0; j < valLength; j++) { if (read(arr, i + j) !== read(val, j)) { found = false break } } if (found) return i } } return -1 } Buffer.prototype.includes = function includes (val, byteOffset, encoding) { return this.indexOf(val, byteOffset, encoding) !== -1 } Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, true) } Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, false) } function hexWrite (buf, string, offset, length) { offset = Number(offset) || 0 var remaining = buf.length - offset if (!length) { length = remaining } else { length = Number(length) if (length > remaining) { length = remaining } } // must be an even number of digits var strLen = string.length if (strLen % 2 !== 0) throw new TypeError('Invalid hex string') if (length > strLen / 2) { length = strLen / 2 } for (var i = 0; i < length; ++i) { var parsed = parseInt(string.substr(i * 2, 2), 16) if (isNaN(parsed)) return i buf[offset + i] = parsed } return i } function utf8Write (buf, string, offset, length) { return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length) } function asciiWrite (buf, string, offset, length) { return blitBuffer(asciiToBytes(string), buf, offset, length) } function latin1Write (buf, string, offset, length) { return asciiWrite(buf, string, offset, length) } function base64Write (buf, string, offset, length) { return blitBuffer(base64ToBytes(string), buf, offset, length) } function ucs2Write (buf, string, offset, length) { return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length) } Buffer.prototype.write = function write (string, offset, length, encoding) { // Buffer#write(string) if (offset === undefined) { encoding = 'utf8' length = this.length offset = 0 // Buffer#write(string, encoding) } else if (length === undefined && typeof offset === 'string') { encoding = offset length = this.length offset = 0 // Buffer#write(string, offset[, length][, encoding]) } else if (isFinite(offset)) { offset = offset | 0 if (isFinite(length)) { length = length | 0 if (encoding === undefined) encoding = 'utf8' } else { encoding = length length = undefined } // legacy write(string, encoding, offset, length) - remove in v0.13 } else { throw new Error( 'Buffer.write(string, encoding, offset[, length]) is no longer supported' ) } var remaining = this.length - offset if (length === undefined || length > remaining) length = remaining if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) { throw new RangeError('Attempt to write outside buffer bounds') } if (!encoding) encoding = 'utf8' var loweredCase = false for (;;) { switch (encoding) { case 'hex': return hexWrite(this, string, offset, length) case 'utf8': case 'utf-8': return utf8Write(this, string, offset, length) case 'ascii': return asciiWrite(this, string, offset, length) case 'latin1': case 'binary': return latin1Write(this, string, offset, length) case 'base64': // Warning: maxLength not taken into account in base64Write return base64Write(this, string, offset, length) case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return ucs2Write(this, string, offset, length) default: if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding) encoding = ('' + encoding).toLowerCase() loweredCase = true } } } Buffer.prototype.toJSON = function toJSON () { return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) } } function base64Slice (buf, start, end) { if (start === 0 && end === buf.length) { return base64.fromByteArray(buf) } else { return base64.fromByteArray(buf.slice(start, end)) } } function utf8Slice (buf, start, end) { end = Math.min(buf.length, end) var res = [] var i = start while (i < end) { var firstByte = buf[i] var codePoint = null var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1 if (i + bytesPerSequence <= end) { var secondByte, thirdByte, fourthByte, tempCodePoint switch (bytesPerSequence) { case 1: if (firstByte < 0x80) { codePoint = firstByte } break case 2: secondByte = buf[i + 1] if ((secondByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F) if (tempCodePoint > 0x7F) { codePoint = tempCodePoint } } break case 3: secondByte = buf[i + 1] thirdByte = buf[i + 2] if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F) if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) { codePoint = tempCodePoint } } break case 4: secondByte = buf[i + 1] thirdByte = buf[i + 2] fourthByte = buf[i + 3] if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F) if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) { codePoint = tempCodePoint } } } } if (codePoint === null) { // we did not generate a valid codePoint so insert a // replacement char (U+FFFD) and advance only 1 byte codePoint = 0xFFFD bytesPerSequence = 1 } else if (codePoint > 0xFFFF) { // encode to utf16 (surrogate pair dance) codePoint -= 0x10000 res.push(codePoint >>> 10 & 0x3FF | 0xD800) codePoint = 0xDC00 | codePoint & 0x3FF } res.push(codePoint) i += bytesPerSequence } return decodeCodePointsArray(res) } // Based on http://stackoverflow.com/a/22747272/680742, the browser with // the lowest limit is Chrome, with 0x10000 args. // We go 1 magnitude less, for safety var MAX_ARGUMENTS_LENGTH = 0x1000 function decodeCodePointsArray (codePoints) { var len = codePoints.length if (len <= MAX_ARGUMENTS_LENGTH) { return String.fromCharCode.apply(String, codePoints) // avoid extra slice() } // Decode in chunks to avoid "call stack size exceeded". var res = '' var i = 0 while (i < len) { res += String.fromCharCode.apply( String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH) ) } return res } function asciiSlice (buf, start, end) { var ret = '' end = Math.min(buf.length, end) for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i] & 0x7F) } return ret } function latin1Slice (buf, start, end) { var ret = '' end = Math.min(buf.length, end) for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i]) } return ret } function hexSlice (buf, start, end) { var len = buf.length if (!start || start < 0) start = 0 if (!end || end < 0 || end > len) end = len var out = '' for (var i = start; i < end; ++i) { out += toHex(buf[i]) } return out } function utf16leSlice (buf, start, end) { var bytes = buf.slice(start, end) var res = '' for (var i = 0; i < bytes.length; i += 2) { res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256) } return res } Buffer.prototype.slice = function slice (start, end) { var len = this.length start = ~~start end = end === undefined ? len : ~~end if (start < 0) { start += len if (start < 0) start = 0 } else if (start > len) { start = len } if (end < 0) { end += len if (end < 0) end = 0 } else if (end > len) { end = len } if (end < start) end = start var newBuf if (Buffer.TYPED_ARRAY_SUPPORT) { newBuf = this.subarray(start, end) newBuf.__proto__ = Buffer.prototype } else { var sliceLen = end - start newBuf = new Buffer(sliceLen, undefined) for (var i = 0; i < sliceLen; ++i) { newBuf[i] = this[i + start] } } return newBuf } /* * Need to make sure that buffer isn't trying to write out of bounds. */ function checkOffset (offset, ext, length) { if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint') if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length') } Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var val = this[offset] var mul = 1 var i = 0 while (++i < byteLength && (mul *= 0x100)) { val += this[offset + i] * mul } return val } Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { checkOffset(offset, byteLength, this.length) } var val = this[offset + --byteLength] var mul = 1 while (byteLength > 0 && (mul *= 0x100)) { val += this[offset + --byteLength] * mul } return val } Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length) return this[offset] } Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) return this[offset] | (this[offset + 1] << 8) } Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) return (this[offset] << 8) | this[offset + 1] } Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000) } Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]) } Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var val = this[offset] var mul = 1 var i = 0 while (++i < byteLength && (mul *= 0x100)) { val += this[offset + i] * mul } mul *= 0x80 if (val >= mul) val -= Math.pow(2, 8 * byteLength) return val } Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var i = byteLength var mul = 1 var val = this[offset + --i] while (i > 0 && (mul *= 0x100)) { val += this[offset + --i] * mul } mul *= 0x80 if (val >= mul) val -= Math.pow(2, 8 * byteLength) return val } Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length) if (!(this[offset] & 0x80)) return (this[offset]) return ((0xff - this[offset] + 1) * -1) } Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) var val = this[offset] | (this[offset + 1] << 8) return (val & 0x8000) ? val | 0xFFFF0000 : val } Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) var val = this[offset + 1] | (this[offset] << 8) return (val & 0x8000) ? val | 0xFFFF0000 : val } Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24) } Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]) } Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ieee754.read(this, offset, true, 23, 4) } Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ieee754.read(this, offset, false, 23, 4) } Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length) return ieee754.read(this, offset, true, 52, 8) } Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length) return ieee754.read(this, offset, false, 52, 8) } function checkInt (buf, value, offset, ext, max, min) { if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance') if (value > max || value < min) throw new RangeError('"value" argument is out of bounds') if (offset + ext > buf.length) throw new RangeError('Index out of range') } Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1 checkInt(this, value, offset, byteLength, maxBytes, 0) } var mul = 1 var i = 0 this[offset] = value & 0xFF while (++i < byteLength && (mul *= 0x100)) { this[offset + i] = (value / mul) & 0xFF } return offset + byteLength } Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1 checkInt(this, value, offset, byteLength, maxBytes, 0) } var i = byteLength - 1 var mul = 1 this[offset + i] = value & 0xFF while (--i >= 0 && (mul *= 0x100)) { this[offset + i] = (value / mul) & 0xFF } return offset + byteLength } Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0) if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value) this[offset] = (value & 0xff) return offset + 1 } function objectWriteUInt16 (buf, value, offset, littleEndian) { if (value < 0) value = 0xffff + value + 1 for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) { buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8 } } Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 } Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 8) this[offset + 1] = (value & 0xff) } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 } function objectWriteUInt32 (buf, value, offset, littleEndian) { if (value < 0) value = 0xffffffff + value + 1 for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) { buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff } } Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset + 3] = (value >>> 24) this[offset + 2] = (value >>> 16) this[offset + 1] = (value >>> 8) this[offset] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 } Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 24) this[offset + 1] = (value >>> 16) this[offset + 2] = (value >>> 8) this[offset + 3] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 } Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1) checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = 0 var mul = 1 var sub = 0 this[offset] = value & 0xFF while (++i < byteLength && (mul *= 0x100)) { if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) { sub = 1 } this[offset + i] = ((value / mul) >> 0) - sub & 0xFF } return offset + byteLength } Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1) checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = byteLength - 1 var mul = 1 var sub = 0 this[offset + i] = value & 0xFF while (--i >= 0 && (mul *= 0x100)) { if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) { sub = 1 } this[offset + i] = ((value / mul) >> 0) - sub & 0xFF } return offset + byteLength } Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80) if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value) if (value < 0) value = 0xff + value + 1 this[offset] = (value & 0xff) return offset + 1 } Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 } Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 8) this[offset + 1] = (value & 0xff) } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 } Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) this[offset + 2] = (value >>> 16) this[offset + 3] = (value >>> 24) } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 } Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000) if (value < 0) value = 0xffffffff + value + 1 if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 24) this[offset + 1] = (value >>> 16) this[offset + 2] = (value >>> 8) this[offset + 3] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 } function checkIEEE754 (buf, value, offset, ext, max, min) { if (offset + ext > buf.length) throw new RangeError('Index out of range') if (offset < 0) throw new RangeError('Index out of range') } function writeFloat (buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38) } ieee754.write(buf, value, offset, littleEndian, 23, 4) return offset + 4 } Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) { return writeFloat(this, value, offset, true, noAssert) } Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) { return writeFloat(this, value, offset, false, noAssert) } function writeDouble (buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308) } ieee754.write(buf, value, offset, littleEndian, 52, 8) return offset + 8 } Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) { return writeDouble(this, value, offset, true, noAssert) } Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) { return writeDouble(this, value, offset, false, noAssert) } // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length) Buffer.prototype.copy = function copy (target, targetStart, start, end) { if (!start) start = 0 if (!end && end !== 0) end = this.length if (targetStart >= target.length) targetStart = target.length if (!targetStart) targetStart = 0 if (end > 0 && end < start) end = start // Copy 0 bytes; we're done if (end === start) return 0 if (target.length === 0 || this.length === 0) return 0 // Fatal error conditions if (targetStart < 0) { throw new RangeError('targetStart out of bounds') } if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds') if (end < 0) throw new RangeError('sourceEnd out of bounds') // Are we oob? if (end > this.length) end = this.length if (target.length - targetStart < end - start) { end = target.length - targetStart + start } var len = end - start var i if (this === target && start < targetStart && targetStart < end) { // descending copy from end for (i = len - 1; i >= 0; --i) { target[i + targetStart] = this[i + start] } } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) { // ascending copy from start for (i = 0; i < len; ++i) { target[i + targetStart] = this[i + start] } } else { Uint8Array.prototype.set.call( target, this.subarray(start, start + len), targetStart ) } return len } // Usage: // buffer.fill(number[, offset[, end]]) // buffer.fill(buffer[, offset[, end]]) // buffer.fill(string[, offset[, end]][, encoding]) Buffer.prototype.fill = function fill (val, start, end, encoding) { // Handle string cases: if (typeof val === 'string') { if (typeof start === 'string') { encoding = start start = 0 end = this.length } else if (typeof end === 'string') { encoding = end end = this.length } if (val.length === 1) { var code = val.charCodeAt(0) if (code < 256) { val = code } } if (encoding !== undefined && typeof encoding !== 'string') { throw new TypeError('encoding must be a string') } if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) { throw new TypeError('Unknown encoding: ' + encoding) } } else if (typeof val === 'number') { val = val & 255 } // Invalid ranges are not set to a default, so can range check early. if (start < 0 || this.length < start || this.length < end) { throw new RangeError('Out of range index') } if (end <= start) { return this } start = start >>> 0 end = end === undefined ? this.length : end >>> 0 if (!val) val = 0 var i if (typeof val === 'number') { for (i = start; i < end; ++i) { this[i] = val } } else { var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString()) var len = bytes.length for (i = 0; i < end - start; ++i) { this[i + start] = bytes[i % len] } } return this } // HELPER FUNCTIONS // ================ var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g function base64clean (str) { // Node strips out invalid characters like \n and \t from the string, base64-js does not str = stringtrim(str).replace(INVALID_BASE64_RE, '') // Node converts strings with length < 2 to '' if (str.length < 2) return '' // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not while (str.length % 4 !== 0) { str = str + '=' } return str } function stringtrim (str) { if (str.trim) return str.trim() return str.replace(/^\s+|\s+$/g, '') } function toHex (n) { if (n < 16) return '0' + n.toString(16) return n.toString(16) } function utf8ToBytes (string, units) { units = units || Infinity var codePoint var length = string.length var leadSurrogate = null var bytes = [] for (var i = 0; i < length; ++i) { codePoint = string.charCodeAt(i) // is surrogate component if (codePoint > 0xD7FF && codePoint < 0xE000) { // last char was a lead if (!leadSurrogate) { // no lead yet if (codePoint > 0xDBFF) { // unexpected trail if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) continue } else if (i + 1 === length) { // unpaired lead if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) continue } // valid lead leadSurrogate = codePoint continue } // 2 leads in a row if (codePoint < 0xDC00) { if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) leadSurrogate = codePoint continue } // valid surrogate pair codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000 } else if (leadSurrogate) { // valid bmp char, but last char was a lead if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) } leadSurrogate = null // encode utf8 if (codePoint < 0x80) { if ((units -= 1) < 0) break bytes.push(codePoint) } else if (codePoint < 0x800) { if ((units -= 2) < 0) break bytes.push( codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80 ) } else if (codePoint < 0x10000) { if ((units -= 3) < 0) break bytes.push( codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80 ) } else if (codePoint < 0x110000) { if ((units -= 4) < 0) break bytes.push( codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80 ) } else { throw new Error('Invalid code point') } } return bytes } function asciiToBytes (str) { var byteArray = [] for (var i = 0; i < str.length; ++i) { // Node's code seems to be doing this and not & 0x7F.. byteArray.push(str.charCodeAt(i) & 0xFF) } return byteArray } function utf16leToBytes (str, units) { var c, hi, lo var byteArray = [] for (var i = 0; i < str.length; ++i) { if ((units -= 2) < 0) break c = str.charCodeAt(i) hi = c >> 8 lo = c % 256 byteArray.push(lo) byteArray.push(hi) } return byteArray } function base64ToBytes (str) { return base64.toByteArray(base64clean(str)) } function blitBuffer (src, dst, offset, length) { for (var i = 0; i < length; ++i) { if ((i + offset >= dst.length) || (i >= src.length)) break dst[i + offset] = src[i] } return i } function isnan (val) { return val !== val // eslint-disable-line no-self-compare } ////////////////// // WEBPACK FOOTER // ./~/buffer/index.js // module id = 3 // module chunks = 0",
"'use strict' exports.byteLength = byteLength exports.toByteArray = toByteArray exports.fromByteArray = fromByteArray var lookup = [] var revLookup = [] var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' for (var i = 0, len = code.length; i < len; ++i) { lookup[i] = code[i] revLookup[code.charCodeAt(i)] = i } revLookup['-'.charCodeAt(0)] = 62 revLookup['_'.charCodeAt(0)] = 63 function placeHoldersCount (b64) { var len = b64.length if (len % 4 > 0) { throw new Error('Invalid string. Length must be a multiple of 4') } // the number of equal signs (place holders) // if there are two placeholders, than the two characters before it // represent one byte // if there is only one, then the three characters before it represent 2 bytes // this is just a cheap hack to not do indexOf twice return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0 } function byteLength (b64) { // base64 is 4/3 + up to two characters of the original data return b64.length * 3 / 4 - placeHoldersCount(b64) } function toByteArray (b64) { var i, j, l, tmp, placeHolders, arr var len = b64.length placeHolders = placeHoldersCount(b64) arr = new Arr(len * 3 / 4 - placeHolders) // if there are placeholders, only get up to the last complete 4 chars l = placeHolders > 0 ? len - 4 : len var L = 0 for (i = 0, j = 0; i < l; i += 4, j += 3) { tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)] arr[L++] = (tmp >> 16) & 0xFF arr[L++] = (tmp >> 8) & 0xFF arr[L++] = tmp & 0xFF } if (placeHolders === 2) { tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4) arr[L++] = tmp & 0xFF } else if (placeHolders === 1) { tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2) arr[L++] = (tmp >> 8) & 0xFF arr[L++] = tmp & 0xFF } return arr } function tripletToBase64 (num) { return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F] } function encodeChunk (uint8, start, end) { var tmp var output = [] for (var i = start; i < end; i += 3) { tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]) output.push(tripletToBase64(tmp)) } return output.join('') } function fromByteArray (uint8) { var tmp var len = uint8.length var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes var output = '' var parts = [] var maxChunkLength = 16383 // must be multiple of 3 // go through the array every three bytes, we'll deal with trailing stuff later for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) { parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength))) } // pad the end with zeros, but make sure to not forget the extra bytes if (extraBytes === 1) { tmp = uint8[len - 1] output += lookup[tmp >> 2] output += lookup[(tmp << 4) & 0x3F] output += '==' } else if (extraBytes === 2) { tmp = (uint8[len - 2] << 8) + (uint8[len - 1]) output += lookup[tmp >> 10] output += lookup[(tmp >> 4) & 0x3F] output += lookup[(tmp << 2) & 0x3F] output += '=' } parts.push(output) return parts.join('') } ////////////////// // WEBPACK FOOTER // ./~/base64-js/index.js // module id = 4 // module chunks = 0",
"exports.read = function (buffer, offset, isLE, mLen, nBytes) { var e, m var eLen = nBytes * 8 - mLen - 1 var eMax = (1 << eLen) - 1 var eBias = eMax >> 1 var nBits = -7 var i = isLE ? (nBytes - 1) : 0 var d = isLE ? -1 : 1 var s = buffer[offset + i] i += d e = s & ((1 << (-nBits)) - 1) s >>= (-nBits) nBits += eLen for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {} m = e & ((1 << (-nBits)) - 1) e >>= (-nBits) nBits += mLen for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {} if (e === 0) { e = 1 - eBias } else if (e === eMax) { return m ? NaN : ((s ? -1 : 1) * Infinity) } else { m = m + Math.pow(2, mLen) e = e - eBias } return (s ? -1 : 1) * m * Math.pow(2, e - mLen) } exports.write = function (buffer, value, offset, isLE, mLen, nBytes) { var e, m, c var eLen = nBytes * 8 - mLen - 1 var eMax = (1 << eLen) - 1 var eBias = eMax >> 1 var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0) var i = isLE ? 0 : (nBytes - 1) var d = isLE ? 1 : -1 var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0 value = Math.abs(value) if (isNaN(value) || value === Infinity) { m = isNaN(value) ? 1 : 0 e = eMax } else { e = Math.floor(Math.log(value) / Math.LN2) if (value * (c = Math.pow(2, -e)) < 1) { e-- c *= 2 } if (e + eBias >= 1) { value += rt / c } else { value += rt * Math.pow(2, 1 - eBias) } if (value * c >= 2) { e++ c /= 2 } if (e + eBias >= eMax) { m = 0 e = eMax } else if (e + eBias >= 1) { m = (value * c - 1) * Math.pow(2, mLen) e = e + eBias } else { m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen) e = 0 } } for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {} e = (e << mLen) | m eLen += mLen for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {} buffer[offset + i - d] |= s * 128 } ////////////////// // WEBPACK FOOTER // ./~/ieee754/index.js // module id = 5 // module chunks = 0",
"var toString = {}.toString; module.exports = Array.isArray || function (arr) { return toString.call(arr) == '[object Array]'; }; ////////////////// // WEBPACK FOOTER // ./~/isarray/index.js // module id = 6 // module chunks = 0",
"'use strict'; module.exports = function bind(fn, thisArg) { return function wrap() { var args = new Array(arguments.length); for (var i = 0; i < args.length; i++) { args[i] = arguments[i]; } return fn.apply(thisArg, args); }; }; ////////////////// // WEBPACK FOOTER // ./lib/helpers/bind.js // module id = 7 // module chunks = 0",
"'use strict'; var defaults = require('./../defaults'); var utils = require('./../utils'); var InterceptorManager = require('./InterceptorManager'); var dispatchRequest = require('./dispatchRequest'); var isAbsoluteURL = require('./../helpers/isAbsoluteURL'); var combineURLs = require('./../helpers/combineURLs'); /** * Create a new instance of Axios * * @param {Object} instanceConfig The default config for the instance */ function Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() }; } /** * Dispatch a request * * @param {Object} config The config specific for this request (merged with this.defaults) */ Axios.prototype.request = function request(config) { /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API if (typeof config === 'string') { config = utils.merge({ url: arguments[0] }, arguments[1]); } config = utils.merge(defaults, this.defaults, { method: 'get' }, config); // Support baseURL config if (config.baseURL && !isAbsoluteURL(config.url)) { config.url = combineURLs(config.baseURL, config.url); } // Hook up interceptors middleware var chain = [dispatchRequest, undefined]; var promise = Promise.resolve(config); this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected); }); this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected); }); while (chain.length) { promise = promise.then(chain.shift(), chain.shift()); } return promise; }; // Provide aliases for supported request methods utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) { return this.request(utils.merge(config || {}, { method: method, url: url })); }; }); utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) { return this.request(utils.merge(config || {}, { method: method, url: url, data: data })); }; }); module.exports = Axios; ////////////////// // WEBPACK FOOTER // ./lib/core/Axios.js // module id = 8 // module chunks = 0",
"'use strict'; var utils = require('./utils'); var normalizeHeaderName = require('./helpers/normalizeHeaderName'); var DEFAULT_CONTENT_TYPE = { 'Content-Type': 'application/x-www-form-urlencoded' }; function setContentTypeIfUnset(headers, value) { if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) { headers['Content-Type'] = value; } } function getDefaultAdapter() { var adapter; if (typeof XMLHttpRequest !== 'undefined') { // For browsers use XHR adapter adapter = require('./adapters/xhr'); } else if (typeof process !== 'undefined') { // For node use HTTP adapter adapter = require('./adapters/http'); } return adapter; } var defaults = { adapter: getDefaultAdapter(), transformRequest: [function transformRequest(data, headers) { normalizeHeaderName(headers, 'Content-Type'); if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data) ) { return data; } if (utils.isArrayBufferView(data)) { return data.buffer; } if (utils.isURLSearchParams(data)) { setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'); return data.toString(); } if (utils.isObject(data)) { setContentTypeIfUnset(headers, 'application/json;charset=utf-8'); return JSON.stringify(data); } return data; }], transformResponse: [function transformResponse(data) { /*eslint no-param-reassign:0*/ if (typeof data === 'string') { try { data = JSON.parse(data); } catch (e) { /* Ignore */ } } return data; }], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, validateStatus: function validateStatus(status) { return status >= 200 && status < 300; } }; defaults.headers = { common: { 'Accept': 'application/json, text/plain, */*' } }; utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) { defaults.headers[method] = {}; }); utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE); }); module.exports = defaults; ////////////////// // WEBPACK FOOTER // ./lib/defaults.js // module id = 9 // module chunks = 0",
"'use strict'; var utils = require('../utils'); module.exports = function normalizeHeaderName(headers, normalizedName) { utils.forEach(headers, function processHeader(value, name) { if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) { headers[normalizedName] = value; delete headers[name]; } }); }; ////////////////// // WEBPACK FOOTER // ./lib/helpers/normalizeHeaderName.js // module id = 10 // module chunks = 0",
"'use strict'; var utils = require('./../utils'); var settle = require('./../core/settle'); var buildURL = require('./../helpers/buildURL'); var parseHeaders = require('./../helpers/parseHeaders'); var isURLSameOrigin = require('./../helpers/isURLSameOrigin'); var createError = require('../core/createError'); var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || require('./../helpers/btoa'); module.exports = function xhrAdapter(config) { return new Promise(function dispatchXhrRequest(resolve, reject) { var requestData = config.data; var requestHeaders = config.headers; if (utils.isFormData(requestData)) { delete requestHeaders['Content-Type']; // Let the browser set it } var request = new XMLHttpRequest(); var loadEvent = 'onreadystatechange'; var xDomain = false; // For IE 8/9 CORS support // Only supports POST and GET calls and doesn't returns the response headers. // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest. if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) { request = new window.XDomainRequest(); loadEvent = 'onload'; xDomain = true; request.onprogress = function handleProgress() {}; request.ontimeout = function handleTimeout() {}; } // HTTP basic authentication if (config.auth) { var username = config.auth.username || ''; var password = config.auth.password || ''; requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password); } request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS request.timeout = config.timeout; // Listen for ready state request[loadEvent] = function handleLoad() { if (!request || (request.readyState !== 4 && !xDomain)) { return; } // The request errored out and we didn't get a response, this will be // handled by onerror instead // With one exception: request that using file: protocol, most browsers // will return status as 0 even though it's a successful request if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) { return; } // Prepare the response var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null; var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response; var response = { data: responseData, // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201) status: request.status === 1223 ? 204 : request.status, statusText: request.status === 1223 ? 'No Content' : request.statusText, headers: responseHeaders, config: config, request: request }; settle(resolve, reject, response); // Clean up request request = null; }; // Handle low level network errors request.onerror = function handleError() { // Real errors are hidden from us by the browser // onerror should only fire if it's a network error reject(createError('Network Error', config)); // Clean up request request = null; }; // Handle timeout request.ontimeout = function handleTimeout() { reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED')); // Clean up request request = null; }; // Add xsrf header // This is only done if running in a standard browser environment. // Specifically not if we're in a web worker, or react-native. if (utils.isStandardBrowserEnv()) { var cookies = require('./../helpers/cookies'); // Add xsrf header var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined; if (xsrfValue) { requestHeaders[config.xsrfHeaderName] = xsrfValue; } } // Add headers to the request if ('setRequestHeader' in request) { utils.forEach(requestHeaders, function setRequestHeader(val, key) { if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') { // Remove Content-Type if data is undefined delete requestHeaders[key]; } else { // Otherwise add header to the request request.setRequestHeader(key, val); } }); } // Add withCredentials to request if needed if (config.withCredentials) { request.withCredentials = true; } // Add responseType to request if needed if (config.responseType) { try { request.responseType = config.responseType; } catch (e) { // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2. // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function. if (config.responseType !== 'json') { throw e; } } } // Handle progress if needed if (typeof config.onDownloadProgress === 'function') { request.addEventListener('progress', config.onDownloadProgress); } // Not all browsers support upload events if (typeof config.onUploadProgress === 'function' && request.upload) { request.upload.addEventListener('progress', config.onUploadProgress); } if (config.cancelToken) { // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) { if (!request) { return; } request.abort(); reject(cancel); // Clean up request request = null; }); } if (requestData === undefined) { requestData = null; } // Send the request request.send(requestData); }); }; ////////////////// // WEBPACK FOOTER // ./lib/adapters/xhr.js // module id = 11 // module chunks = 0",
"'use strict'; var createError = require('./createError'); /** * Resolve or reject a Promise based on response status. * * @param {Function} resolve A function that resolves the promise. * @param {Function} reject A function that rejects the promise. * @param {object} response The response. */ module.exports = function settle(resolve, reject, response) { var validateStatus = response.config.validateStatus; // Note: status is not exposed by XDomainRequest if (!response.status || !validateStatus || validateStatus(response.status)) { resolve(response); } else { reject(createError( 'Request failed with status code ' + response.status, response.config, null, response )); } }; ////////////////// // WEBPACK FOOTER // ./lib/core/settle.js // module id = 12 // module chunks = 0",
"'use strict'; var enhanceError = require('./enhanceError'); /** * Create an Error with the specified message, config, error code, and response. * * @param {string} message The error message. * @param {Object} config The config. * @param {string} [code] The error code (for example, 'ECONNABORTED'). @ @param {Object} [response] The response. * @returns {Error} The created error. */ module.exports = function createError(message, config, code, response) { var error = new Error(message); return enhanceError(error, config, code, response); }; ////////////////// // WEBPACK FOOTER // ./lib/core/createError.js // module id = 13 // module chunks = 0",
"'use strict'; /** * Update an Error with the specified config, error code, and response. * * @param {Error} error The error to update. * @param {Object} config The config. * @param {string} [code] The error code (for example, 'ECONNABORTED'). @ @param {Object} [response] The response. * @returns {Error} The error. */ module.exports = function enhanceError(error, config, code, response) { error.config = config; if (code) { error.code = code; } error.response = response; return error; }; ////////////////// // WEBPACK FOOTER // ./lib/core/enhanceError.js // module id = 14 // module chunks = 0",
"'use strict'; var utils = require('./../utils'); function encode(val) { return encodeURIComponent(val). replace(/%40/gi, '@'). replace(/%3A/gi, ':'). replace(/%24/g, '$'). replace(/%2C/gi, ','). replace(/%20/g, '+'). replace(/%5B/gi, '['). replace(/%5D/gi, ']'); } /** * Build a URL by appending params to the end * * @param {string} url The base of the url (e.g., http://www.google.com) * @param {object} [params] The params to be appended * @returns {string} The formatted url */ module.exports = function buildURL(url, params, paramsSerializer) { /*eslint no-param-reassign:0*/ if (!params) { return url; } var serializedParams; if (paramsSerializer) { serializedParams = paramsSerializer(params); } else if (utils.isURLSearchParams(params)) { serializedParams = params.toString(); } else { var parts = []; utils.forEach(params, function serialize(val, key) { if (val === null || typeof val === 'undefined') { return; } if (utils.isArray(val)) { key = key + '[]'; } if (!utils.isArray(val)) { val = [val]; } utils.forEach(val, function parseValue(v) { if (utils.isDate(v)) { v = v.toISOString(); } else if (utils.isObject(v)) { v = JSON.stringify(v); } parts.push(encode(key) + '=' + encode(v)); }); }); serializedParams = parts.join('&'); } if (serializedParams) { url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams; } return url; }; ////////////////// // WEBPACK FOOTER // ./lib/helpers/buildURL.js // module id = 15 // module chunks = 0",
"'use strict'; var utils = require('./../utils'); /** * Parse headers into an object * * ``` * Date: Wed, 27 Aug 2014 08:58:49 GMT * Content-Type: application/json * Connection: keep-alive * Transfer-Encoding: chunked * ``` * * @param {String} headers Headers needing to be parsed * @returns {Object} Headers parsed into an object */ module.exports = function parseHeaders(headers) { var parsed = {}; var key; var val; var i; if (!headers) { return parsed; } utils.forEach(headers.split('\n'), function parser(line) { i = line.indexOf(':'); key = utils.trim(line.substr(0, i)).toLowerCase(); val = utils.trim(line.substr(i + 1)); if (key) { parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val; } }); return parsed; }; ////////////////// // WEBPACK FOOTER // ./lib/helpers/parseHeaders.js // module id = 16 // module chunks = 0",
"'use strict'; var utils = require('./../utils'); module.exports = ( utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test // whether the request URL is of the same origin as current location. (function standardBrowserEnv() { var msie = /(msie|trident)/i.test(navigator.userAgent); var urlParsingNode = document.createElement('a'); var originURL; /** * Parse a URL to discover it's components * * @param {String} url The URL to be parsed * @returns {Object} */ function resolveURL(url) { var href = url; if (msie) { // IE needs attribute set twice to normalize properties urlParsingNode.setAttribute('href', href); href = urlParsingNode.href; } urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils return { href: urlParsingNode.href, protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '', host: urlParsingNode.host, search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '', hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '', hostname: urlParsingNode.hostname, port: urlParsingNode.port, pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname }; } originURL = resolveURL(window.location.href); /** * Determine if a URL shares the same origin as the current location * * @param {String} requestURL The URL to test * @returns {boolean} True if URL shares the same origin, otherwise false */ return function isURLSameOrigin(requestURL) { var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL; return (parsed.protocol === originURL.protocol && parsed.host === originURL.host); }; })() : // Non standard browser envs (web workers, react-native) lack needed support. (function nonStandardBrowserEnv() { return function isURLSameOrigin() { return true; }; })() ); ////////////////// // WEBPACK FOOTER // ./lib/helpers/isURLSameOrigin.js // module id = 17 // module chunks = 0",
"'use strict'; // btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; function E() { this.message = 'String contains an invalid character'; } E.prototype = new Error; E.prototype.code = 5; E.prototype.name = 'InvalidCharacterError'; function btoa(input) { var str = String(input); var output = ''; for ( // initialize result and counter var block, charCode, idx = 0, map = chars; // if the next str index does not exist: // change the mapping table to "=" // check if d has no fractional digits str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8 output += map.charAt(63 & block >> 8 - idx % 1 * 8) ) { charCode = str.charCodeAt(idx += 3 / 4); if (charCode > 0xFF) { throw new E(); } block = block << 8 | charCode; } return output; } module.exports = btoa; ////////////////// // WEBPACK FOOTER // ./lib/helpers/btoa.js // module id = 18 // module chunks = 0",
"'use strict'; var utils = require('./../utils'); module.exports = ( utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie (function standardBrowserEnv() { return { write: function write(name, value, expires, path, domain, secure) { var cookie = []; cookie.push(name + '=' + encodeURIComponent(value)); if (utils.isNumber(expires)) { cookie.push('expires=' + new Date(expires).toGMTString()); } if (utils.isString(path)) { cookie.push('path=' + path); } if (utils.isString(domain)) { cookie.push('domain=' + domain); } if (secure === true) { cookie.push('secure'); } document.cookie = cookie.join('; '); }, read: function read(name) { var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)')); return (match ? decodeURIComponent(match[3]) : null); }, remove: function remove(name) { this.write(name, '', Date.now() - 86400000); } }; })() : // Non standard browser env (web workers, react-native) lack needed support. (function nonStandardBrowserEnv() { return { write: function write() {}, read: function read() { return null; }, remove: function remove() {} }; })() ); ////////////////// // WEBPACK FOOTER // ./lib/helpers/cookies.js // module id = 19 // module chunks = 0",
"'use strict'; var utils = require('./../utils'); function InterceptorManager() { this.handlers = []; } /** * Add a new interceptor to the stack * * @param {Function} fulfilled The function to handle `then` for a `Promise` * @param {Function} rejected The function to handle `reject` for a `Promise` * * @return {Number} An ID used to remove interceptor later */ InterceptorManager.prototype.use = function use(fulfilled, rejected) { this.handlers.push({ fulfilled: fulfilled, rejected: rejected }); return this.handlers.length - 1; }; /** * Remove an interceptor from the stack * * @param {Number} id The ID that was returned by `use` */ InterceptorManager.prototype.eject = function eject(id) { if (this.handlers[id]) { this.handlers[id] = null; } }; /** * Iterate over all the registered interceptors * * This method is particularly useful for skipping over any * interceptors that may have become `null` calling `eject`. * * @param {Function} fn The function to call for each interceptor */ InterceptorManager.prototype.forEach = function forEach(fn) { utils.forEach(this.handlers, function forEachHandler(h) { if (h !== null) { fn(h); } }); }; module.exports = InterceptorManager; ////////////////// // WEBPACK FOOTER // ./lib/core/InterceptorManager.js // module id = 20 // module chunks = 0",
"'use strict'; var utils = require('./../utils'); var transformData = require('./transformData'); var isCancel = require('../cancel/isCancel'); var defaults = require('../defaults'); /** * Throws a `Cancel` if cancellation has been requested. */ function throwIfCancellationRequested(config) { if (config.cancelToken) { config.cancelToken.throwIfRequested(); } } /** * Dispatch a request to the server using the configured adapter. * * @param {object} config The config that is to be used for the request * @returns {Promise} The Promise to be fulfilled */ module.exports = function dispatchRequest(config) { throwIfCancellationRequested(config); // Ensure headers exist config.headers = config.headers || {}; // Transform request data config.data = transformData( config.data, config.headers, config.transformRequest ); // Flatten headers config.headers = utils.merge( config.headers.common || {}, config.headers[config.method] || {}, config.headers || {} ); utils.forEach( ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) { delete config.headers[method]; } ); var adapter = config.adapter || defaults.adapter; return adapter(config).then(function onAdapterResolution(response) { throwIfCancellationRequested(config); // Transform response data response.data = transformData( response.data, response.headers, config.transformResponse ); return response; }, function onAdapterRejection(reason) { if (!isCancel(reason)) { throwIfCancellationRequested(config); // Transform response data if (reason && reason.response) { reason.response.data = transformData( reason.response.data, reason.response.headers, config.transformResponse ); } } return Promise.reject(reason); }); }; ////////////////// // WEBPACK FOOTER // ./lib/core/dispatchRequest.js // module id = 21 // module chunks = 0",
"'use strict'; var utils = require('./../utils'); /** * Transform the data for a request or a response * * @param {Object|String} data The data to be transformed * @param {Array} headers The headers for the request or response * @param {Array|Function} fns A single function or Array of functions * @returns {*} The resulting transformed data */ module.exports = function transformData(data, headers, fns) { /*eslint no-param-reassign:0*/ utils.forEach(fns, function transform(fn) { data = fn(data, headers); }); return data; }; ////////////////// // WEBPACK FOOTER // ./lib/core/transformData.js // module id = 22 // module chunks = 0",
"'use strict'; module.exports = function isCancel(value) { return !!(value && value.__CANCEL__); }; ////////////////// // WEBPACK FOOTER // ./lib/cancel/isCancel.js // module id = 23 // module chunks = 0",
"'use strict'; /** * Determines whether the specified URL is absolute * * @param {string} url The URL to test * @returns {boolean} True if the specified URL is absolute, otherwise false */ module.exports = function isAbsoluteURL(url) { // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL). // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed // by any combination of letters, digits, plus, period, or hyphen. return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url); }; ////////////////// // WEBPACK FOOTER // ./lib/helpers/isAbsoluteURL.js // module id = 24 // module chunks = 0",
"'use strict'; /** * Creates a new URL by combining the specified URLs * * @param {string} baseURL The base URL * @param {string} relativeURL The relative URL * @returns {string} The combined URL */ module.exports = function combineURLs(baseURL, relativeURL) { return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL; }; ////////////////// // WEBPACK FOOTER // ./lib/helpers/combineURLs.js // module id = 25 // module chunks = 0",
"'use strict'; /** * A `Cancel` is an object that is thrown when an operation is canceled. * * @class * @param {string=} message The message. */ function Cancel(message) { this.message = message; } Cancel.prototype.toString = function toString() { return 'Cancel' + (this.message ? ': ' + this.message : ''); }; Cancel.prototype.__CANCEL__ = true; module.exports = Cancel; ////////////////// // WEBPACK FOOTER // ./lib/cancel/Cancel.js // module id = 26 // module chunks = 0",
"'use strict'; var Cancel = require('./Cancel'); /** * A `CancelToken` is an object that can be used to request cancellation of an operation. * * @class * @param {Function} executor The executor function. */ function CancelToken(executor) { if (typeof executor !== 'function') { throw new TypeError('executor must be a function.'); } var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) { resolvePromise = resolve; }); var token = this; executor(function cancel(message) { if (token.reason) { // Cancellation has already been requested return; } token.reason = new Cancel(message); resolvePromise(token.reason); }); } /** * Throws a `Cancel` if cancellation has been requested. */ CancelToken.prototype.throwIfRequested = function throwIfRequested() { if (this.reason) { throw this.reason; } }; /** * Returns an object that contains a new `CancelToken` and a function that, when called, * cancels the `CancelToken`. */ CancelToken.source = function source() { var cancel; var token = new CancelToken(function executor(c) { cancel = c; }); return { token: token, cancel: cancel }; }; module.exports = CancelToken; ////////////////// // WEBPACK FOOTER // ./lib/cancel/CancelToken.js // module id = 27 // module chunks = 0",
"'use strict'; /** * Syntactic sugar for invoking a function and expanding an array for arguments. * * Common use case would be to use `Function.prototype.apply`. * * ```js * function f(x, y, z) {} * var args = [1, 2, 3]; * f.apply(null, args); * ``` * * With `spread` this example can be re-written. * * ```js * spread(function(x, y, z) {})([1, 2, 3]); * ``` * * @param {Function} callback * @returns {Function} */ module.exports = function spread(callback) { return function wrap(arr) { return callback.apply(null, arr); }; }; ////////////////// // WEBPACK FOOTER // ./lib/helpers/spread.js // module id = 28 // module chunks = 0"
],
sourceRoot: ""
}